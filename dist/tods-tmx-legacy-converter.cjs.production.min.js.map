{"version":3,"file":"tods-tmx-legacy-converter.cjs.production.min.js","sources":["../src/matchFormatCode.js","../src/scoreFormat.js","../src/dateFx.js","../src/extractMatchUp.js","../src/utilities.js","../src/typeCheck.js","../src/courtFx.js","../src/scoreFx.js","../src/UUID.js","../src/drawFx.js","../src/matchFx.js","../src/getStructureContent.js","../src/extractEvents.js","../src/convertTieFormat.js","../src/extractStructures.js","../src/extractParticipants.js","../src/extractTournamentInfo.js","../src/index.js"],"sourcesContent":["/*\n * TODO: if the final set is NOT different then don't include in string\n */\n\nconst SET = \"SET\";\nconst NOAD = \"NOAD\";\nconst TIMED = \"timed\";\nconst FINAL = \"final\";\nconst NORMAL = \"normal\";\nconst setTypes = {\n  S: NORMAL,\n  F: FINAL,\n};\n\nexport const matchFormatCode = (function () {\n  let fx = {};\n\n  fx.stringify = (matchformatobject) => {\n    if (matchformatobject && typeof matchformatobject === \"object\") {\n      if (matchformatobject.timed && !isNaN(matchformatobject.minutes))\n        return timedFormat(matchformatobject);\n      if (matchformatobject.bestOf && matchformatobject.setFormat)\n        return setFormat(matchformatobject);\n    }\n  };\n\n  function timedFormat(matchformatobject) {\n    return `T${matchformatobject.minutes}`;\n  }\n\n  function setFormat(matchformatobject) {\n    let best_of = getNumber(matchformatobject.bestOf);\n    let bestOf = (best_of && `${SET}${best_of}`) || \"\";\n    let normal_set = stringifySet(matchformatobject.setFormat);\n    let normalSet = (normal_set && `S:${normal_set}`) || \"\";\n    let final_set = stringifySet(matchformatobject.finalSetFormat);\n    let finalSet =\n      (best_of > 1 && final_set && !final_set.invalid && `F:${final_set}`) ||\n      \"\";\n    let valid =\n      bestOf &&\n      normal_set &&\n      !normal_set.invalid &&\n      (!final_set || !final_set.invalid);\n    if (valid) {\n      return [bestOf, normalSet, finalSet].filter((f) => f).join(\"-\");\n    }\n  }\n\n  function stringifySet(setobject) {\n    if (setobject) {\n      if (typeof setobject === \"object\") {\n        if (setobject.tiebreakSet) return tiebreakFormat(setobject.tiebreakSet);\n        let setTo = getNumber(setobject.setTo);\n        if (setTo) {\n          let NoAD = (setobject.NoAD && NOAD) || \"\";\n          let set_tiebreak = tiebreakFormat(setobject.tiebreakFormat);\n          let setTiebreak =\n            (set_tiebreak && !set_tiebreak.invalid && `/${set_tiebreak}`) || \"\";\n          let tiebreak_at = getNumber(setobject.tiebreakAt);\n          let tiebreakAt =\n            (tiebreak_at && tiebreak_at !== setTo && `@${tiebreak_at}`) || \"\";\n          let valid = !set_tiebreak || !set_tiebreak.invalid;\n          if (valid) {\n            return `${setTo}${NoAD}${setTiebreak}${tiebreakAt}`;\n          } else {\n            return { invalid: true };\n          }\n        } else {\n          return { invalid: true };\n        }\n      }\n    }\n  }\n\n  function tiebreakFormat(tieobject) {\n    if (tieobject) {\n      if (typeof tieobject === \"object\" && getNumber(tieobject.tiebreakTo)) {\n        return `TB${tieobject.tiebreakTo}${tieobject.NoAD ? NOAD : \"\"}`;\n      } else {\n        return { invalid: true };\n      }\n    }\n  }\n\n  fx.parse = (matchformatcode) => {\n    if (matchformatcode && typeof matchformatcode === \"string\") {\n      let type =\n        matchformatcode.indexOf(\"T\") === 0\n          ? \"timed\"\n          : matchformatcode.indexOf(SET) === 0\n          ? SET\n          : \"\";\n      if (type === TIMED) return timedMatch(matchformatcode);\n      if (type === SET) return setsMatch(matchformatcode);\n    }\n  };\n\n  function setsMatch(formatstring) {\n    let parts = formatstring.split(\"-\");\n\n    let bestOf = getNumber(parts[0].slice(3));\n    let setFormat = parts && parseSetFormat(parts[1]);\n    let finalSetFormat = parts && parseSetFormat(parts[2]);\n\n    let validBestOf = bestOf && bestOf < 6;\n    let validFinalSet =\n      !parts[2] || (finalSetFormat && !finalSetFormat.invalid);\n    let validSetsFormat = setFormat && !setFormat.invalid;\n\n    let result = { bestOf, setFormat };\n    if (finalSetFormat) result.finalSetFormat = finalSetFormat;\n    if (validBestOf && validSetsFormat && validFinalSet) return result;\n  }\n\n  function parseSetFormat(formatstring) {\n    if (formatstring && formatstring[1] === \":\") {\n      let parts = formatstring.split(\":\");\n      let set_type = setTypes[parts[0]];\n      let set_format = parts[1];\n      if (set_type && set_format) {\n        let tiebreakSet = set_format.indexOf(\"TB\") === 0;\n        if (tiebreakSet)\n          return { tiebreakSet: parseTiebreakFormat(set_format) };\n        let parts = formatstring.match(/^[FS]{1}:(\\d+)([A-Za-z]*)/);\n        let NoAD = (parts && isNoAD(parts[2])) || false;\n        let validNoAD = !parts || !parts[2] || NoAD;\n        let setTo = parts && getNumber(parts[1]);\n        let tiebreak_at = parseTiebreakAt(set_format);\n        let validTiebreakAt =\n          !tiebreak_at || (tiebreak_at && !tiebreak_at.invalid);\n        let tiebreakAt = (validTiebreakAt && tiebreak_at) || setTo;\n        let tiebreakFormat = parseTiebreakFormat(set_format.split(\"/\")[1]);\n        let validTiebreak = !tiebreakFormat || !tiebreakFormat.invalid;\n        let result = { setTo };\n        if (NoAD) result.NoAD = true;\n        if (tiebreakFormat) {\n          result.tiebreakFormat = tiebreakFormat;\n          result.tiebreakAt = tiebreakAt;\n        } else {\n          result.noTiebreak = true;\n        }\n        return (\n          (setTo &&\n            validNoAD &&\n            validTiebreak &&\n            validTiebreakAt &&\n            result) || { invalid: true }\n        );\n      }\n    }\n  }\n\n  function parseTiebreakAt(set_format) {\n    let tiebreak_at =\n      set_format && set_format.indexOf(\"@\") > 0 && set_format.split(\"@\");\n    if (tiebreak_at) {\n      let tiebreakAt = getNumber(tiebreak_at[1]);\n      return tiebreakAt || { invalid: true };\n    }\n  }\n\n  function parseTiebreakFormat(formatstring) {\n    if (formatstring) {\n      if (formatstring.indexOf(\"TB\") === 0) {\n        let parts = formatstring.match(/^TB(\\d+)([A-Za-z]*)/);\n        let tiebreak_to = parts && parts[1];\n        let NoAD = parts && isNoAD(parts[2]);\n        let validNoAD = !parts || !parts[2] || NoAD;\n        let tiebreakTo = getNumber(tiebreak_to);\n        if (tiebreakTo && validNoAD) {\n          let result = { tiebreakTo };\n          if (NoAD) result.NoAD = true;\n          return result;\n        } else {\n          return { invalid: true };\n        }\n      } else {\n        return { invalid: true };\n      }\n    }\n  }\n\n  function timedMatch(formatstring) {\n    let timestring = formatstring.slice(1);\n    let minutes = getNumber(timestring);\n    if (minutes) return { timed: true, minutes };\n  }\n\n  function isNoAD(formatstring) {\n    return formatstring && formatstring.indexOf(NOAD) >= 0;\n  }\n\n  function getNumber(formatstring) {\n    return !isNaN(Number(formatstring)) && Number(formatstring);\n  }\n\n  return fx;\n})();\n","/*\n   Convert legacy TMX score_format into JSON representation of TODS MatchFormatCode\n*/\nexport const scoreFormat = (function () {\n  let fx = {};\n\n  fx.jsonTODS = (score_format) => {\n    let tods = { bestOf: getNumber(score_format.max_sets) };\n\n    if (\n      score_format.max_sets &&\n      parseInt(score_format.max_sets) === 1 &&\n      score_format.final_set_supertiebreak\n    ) {\n      tods.setFormat = {\n        tiebreakSet: { tiebreakTo: score_format.supertiebreak_to },\n      };\n    } else {\n      const setTo = getNumber(score_format.games_for_set);\n      const tiebreaks_at = getNumber(score_format.tiereaks_at);\n      const tiebreakAt = tiebreaks_at > setTo ? setTo : tiebreaks_at;\n      tods.setFormat = {\n        setTo,\n        tiebreakAt,\n        tiebreakFormat: { tiebreakTo: getNumber(score_format.tiebreak_to) },\n      };\n      if (score_format.final_set_supertiebreak) {\n        tods.finalSetFormat = {\n          tiebreakSet: { tiebreakTo: score_format.supertiebreak_to },\n        };\n      }\n    }\n\n    return tods;\n  };\n\n  function getNumber(formatstring) {\n    return !isNaN(Number(formatstring)) && Number(formatstring);\n  }\n\n  return fx;\n})();\n","export const dateFx = (function () {\n  let fx = {};\n\n  fx.localizeDate = (date, date_localization, locale) => {\n    let default_localization = {\n      weekday: \"long\",\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n    };\n    return date.toLocaleDateString(\n      locale,\n      date_localization || default_localization\n    );\n  };\n\n  fx.timeSort = timeSort;\n  function timeSort(a, b) {\n    let as = splitTime(a);\n    let bs = splitTime(b);\n    if (parseInt(as.hours) < parseInt(bs.hours)) return -1;\n    if (parseInt(as.hours) > parseInt(bs.hours)) return 1;\n    if (as.hours === bs.hours) {\n      if (parseInt(as.minutes) < parseInt(bs.minutes)) return -1;\n      if (parseInt(as.minutes) > parseInt(bs.minutes)) return 1;\n    }\n    return 0;\n  }\n\n  function splitTime(value) {\n    value = value || \"00:00\";\n    let o = {},\n      time = {};\n    ({ 0: o.time, 1: o.ampm } = (value && value.split(\" \")) || \"\");\n    ({ 0: time.hours, 1: time.minutes } = (o.time && o.time.split(\":\")) || \"\");\n    time.ampm = o.ampm;\n    return time;\n  }\n\n  fx.militaryTime = (value, env) => {\n    let time = splitTime(value || env.schedule.default_time);\n    if (time.ampm && time.hours) {\n      if (time.ampm.toLowerCase() === \"pm\" && parseInt(time.hours) < 12)\n        time.hours = ((time.hours && parseInt(time.hours)) || 0) + 12;\n      if (time.ampm.toLowerCase() === \"am\" && time.hours === \"12\")\n        time.hours = \"00\";\n    }\n    return `${time.hours || \"12\"}:${time.minutes || \"00\"}`;\n  };\n\n  fx.regularTime = (value, env) => {\n    let time = splitTime(value || env.schedule.default_time);\n    if (time.ampm) return value;\n    if (time.hours > 12) {\n      time.hours -= 12;\n      time.ampm = \"PM\";\n    } else if (time.hours === \"12\") {\n      time.ampm = \"PM\";\n    } else if (time.hours === \"00\") {\n      time.hours = \"12\";\n      time.ampm = \"AM\";\n    } else {\n      time.ampm = \"AM\";\n    }\n    return `${time.hours || \"12\"}:${time.minutes || \"00\"} ${time.ampm}`;\n  };\n\n  fx.convertTime = (value, env) => {\n    return !env || env.schedule.time24\n      ? fx.militaryTime(value, env)\n      : fx.regularTime(value, env);\n  };\n\n  fx.addWeek = (date) => {\n    let now = new Date(date);\n    return now.setDate(now.getDate() + 7);\n  };\n  fx.subtractWeek = (date) => {\n    let now = new Date(date);\n    return now.setDate(now.getDate() - 7);\n  };\n  fx.getDateByWeek = getDateByWeek;\n  function getDateByWeek(week, year) {\n    let d = new Date(year, 0, 1);\n    let dayNum = d.getDay();\n    let requiredDate = --week * 7;\n    if (dayNum !== 0 || dayNum > 4) requiredDate += 7;\n    d.setDate(1 - d.getDay() + ++requiredDate);\n    return d;\n  }\n\n  // scoreboard\n  fx.HHMMSS = (s, format) => {\n    var sec_num = parseInt(s, 10); // don't forget the second param\n    var hours = Math.floor(sec_num / 3600);\n    var minutes = Math.floor((sec_num - hours * 3600) / 60);\n    var seconds = sec_num - hours * 3600 - minutes * 60;\n\n    let display_seconds = !format || (format && format.display_seconds);\n    let pad_hours = !format || (format && format.pad_hours);\n    if (hours < 10 && pad_hours) {\n      hours = \"0\" + hours;\n    }\n    if (minutes < 10) {\n      minutes = \"0\" + minutes;\n    }\n    if (seconds < 10) {\n      seconds = \"0\" + seconds;\n    }\n    return display_seconds\n      ? hours + \":\" + minutes + \":\" + seconds\n      : hours + \":\" + minutes;\n  };\n\n  // unused\n  fx.weekDays = (date) => {\n    let dates = [0, 1, 2, 3, 4, 5, 6].map((i) => dayOfWeek(date, i));\n    return dates;\n\n    function dayOfWeek(date, index) {\n      let d = new Date(date);\n      let day = d.getDay();\n      let diff = index - day;\n      return new Date(d.setDate(d.getDate() + diff));\n    }\n  };\n\n  // exportFx\n  fx.ymd2date = ymd2date;\n  function ymd2date(ymd) {\n    let parts = ymd.split(\"-\");\n    if (!parts || parts.length !== 3) return new Date(ymd);\n    if (isNaN(parseInt(parts[1]))) return new Date(ymd);\n    return new Date(parts[0], parseInt(parts[1]) - 1, parts[2]);\n  }\n\n  // ** used frequently\n  fx.formatDate = formatDate;\n  function formatDate(date, separator = \"-\", format = \"YMD\") {\n    if (!date) return \"\";\n    if (!isNaN(date)) date = fx.offsetTime(date);\n\n    let d = new Date(date);\n    let month = \"\" + (d.getMonth() + 1);\n    let day = \"\" + d.getDate();\n    let year = d.getFullYear();\n\n    if (month.length < 2) month = \"0\" + month;\n    if (day.length < 2) day = \"0\" + day;\n\n    if (format === \"DMY\") return [day, month, year].join(separator);\n    if (format === \"MDY\") return [month, day, year].join(separator);\n    if (format === \"YDM\") return [year, day, month].join(separator);\n    if (format === \"DYM\") return [day, year, month].join(separator);\n    if (format === \"MYD\") return [month, year, day].join(separator);\n    return [year, month, day].join(separator);\n  }\n\n  fx.offsetDate = (date) => {\n    var targetTime = date ? new Date(date) : new Date();\n    var tzDifference = targetTime.getTimezoneOffset();\n    return new Date(targetTime.getTime() + tzDifference * 60 * 1000);\n  };\n\n  fx.offsetTime = (date) => fx.offsetDate(date).getTime();\n\n  fx.validDate = (datestring, range) => {\n    if (!datestring) return false;\n    let dateparts = formatDate(datestring).split(\"-\");\n    if (isNaN(dateparts.join(\"\"))) return false;\n    if (dateparts.length !== 3) return false;\n    if (dateparts[0].length !== 4) return false;\n    if (+dateparts[1] > 12 || +dateparts[1] < 1) return false;\n    if (+dateparts[2] > 31 || +dateparts[2] < 1) return false;\n    if (range && range.start) {\n      if (fx.offsetDate(datestring) < fx.offsetDate(range.start)) return false;\n    }\n    if (range && range.end) {\n      if (fx.offsetDate(datestring) > fx.offsetDate(range.end)) return false;\n    }\n    if (new Date(datestring) === \"Invalid Date\") return false;\n    return true;\n  };\n\n  fx.isDate = (dateArg) => {\n    if (typeof dateArg == \"boolean\") return false;\n    var t =\n      dateArg instanceof Date\n        ? dateArg\n        : !isNaN(dateArg)\n        ? new Date(dateArg)\n        : false;\n    return t && !isNaN(t.valueOf());\n  };\n\n  function isValidDateRange(minDate, maxDate) {\n    return fx.offsetDate(minDate) <= fx.offsetDate(maxDate);\n  }\n\n  fx.timeUTC = (date) => {\n    let dateDate = new Date(date);\n    return Date.UTC(\n      dateDate.getFullYear(),\n      dateDate.getMonth(),\n      dateDate.getDate()\n    );\n  };\n\n  fx.dateFromDay = (year, day) => {\n    var date = new Date(year, 0); // initialize a date in `year-01-01`\n    return new Date(date.setDate(day)); // add the number of days\n  };\n  fx.randomDate = (start, end) =>\n    new Date(\n      start.getTime() + Math.random() * (end.getTime() - start.getTime())\n    );\n  fx.dateRange = (startDt, endDt) => {\n    let error =\n      fx.isDate(endDt) && fx.isDate(startDt) && isValidDateRange(startDt, endDt)\n        ? false\n        : true;\n    let between = [];\n    let iterations = 0;\n    let keep_looping = true;\n\n    if (error) {\n      console.log(\"error occured!!!... Please Enter Valid Dates\");\n    } else {\n      var currentDate = fx.offsetDate(startDt);\n      var end = fx.offsetDate(endDt);\n      while (currentDate <= end && keep_looping) {\n        iterations += 1;\n        if (iterations > 300) {\n          console.log(\"excessive while loop\");\n          keep_looping = false;\n        }\n        // must be a *new* Date otherwise it is an array of the same object\n        between.push(new Date(currentDate));\n        currentDate.setDate(currentDate.getDate() + 1);\n      }\n    }\n    return between;\n  };\n\n  // unused\n  fx.sameDay = (d1, d2) => {\n    return (\n      d1.getFullYear() === d2.getFullYear() &&\n      d1.getMonth() === d2.getMonth() &&\n      d1.getDate() === d2.getDate()\n    );\n  };\n\n  fx.futureDate = (days = 1) => {\n    let currentDate = new Date();\n    currentDate.setDate(currentDate.getDate() + days);\n    return currentDate;\n  };\n\n  return fx;\n})();\n","import { matchFormatCode } from \"./matchFormatCode\";\nimport { scoreFormat } from \"./scoreFormat\";\nimport { dateFx } from \"./dateFx\";\nimport {\n  participantRoles,\n  participantConstants,\n  entryStatusConstants,\n  matchUpStatusConstants,\n  mocksEngine,\n} from \"tods-competition-factory\";\n\nexport function extractMatchUp({\n  eventType,\n  seedLimit,\n  tieFormat,\n  entryStage,\n  legacyMatch,\n  participants,\n  matchUpFormat,\n  participantIds,\n  drawPositionOffset = 0,\n  tournamentEngine, // must pass in tournamentEngine that contains state with participants\n}) {\n  const matchUpId = legacyMatch.match?.muid || legacyMatch.muid;\n\n  const sides = [];\n  const entries = [];\n  const seedAssignments = [];\n  const missingParticipants = [];\n  const positionAssignments = [];\n\n  let isBye = false;\n  if (Array.isArray(legacyMatch.teams)) {\n    legacyMatch.teams.forEach((team, index) => {\n      if (!team?.length) return;\n\n      let participantId;\n      const individualParticipantIds = team\n        .map((player) => player?.id)\n        .filter((f) => f);\n\n      const player1 = team && team[0] && typeof team[0] === \"object\" && team[0];\n      const player2 = team && team[1] && typeof team[1] === \"object\" && team[1];\n      const drawPosition =\n        (player1?.draw_position || player2?.draw_position) + drawPositionOffset;\n      const seed = player1?.seed;\n      const bye = player1?.bye;\n\n      if (individualParticipantIds.length === 1) {\n        participantId = individualParticipantIds[0];\n      }\n      if (individualParticipantIds.length === 2) {\n        let { participant } = tournamentEngine.getPairedParticipant({\n          participantIds: individualParticipantIds,\n        });\n        if (!participant) {\n          ({ participant } = tournamentEngine.addParticipant({\n            participant: {\n              participantType: \"PAIR\",\n              participantRole: \"COMPETITOR\",\n              individualParticipantIds: [player1.id, player2.id],\n            },\n          }));\n          missingParticipants.push(participant);\n        }\n        participantId = participant?.participantId;\n      }\n\n      const side = { sideNumber: index + 1 };\n      if (drawPosition) side.drawPosition = drawPosition;\n      if (bye) {\n        side.bye = bye;\n        isBye = true;\n      }\n      if (participantId) {\n        side.participantId = participantId;\n      }\n      sides.push(side);\n\n      if (participantId && !participantIds.includes(participantId)) {\n        participantIds.push(participantId);\n        const entry = {\n          entryStage,\n          participantId,\n          entryStatus: entryStatusConstants.DIRECT_ACCEPTANCE,\n        };\n        entries.push(entry);\n        const positionAssignment = { drawPosition, participantId };\n        positionAssignments.push(positionAssignment);\n        if (seed && seed <= seedLimit) {\n          const seedAssignment = {\n            seedNumber: seed,\n            seedValue: seed, // TODO: check whether there is a seed display value in TMX 1.9\n            participantId,\n          };\n          seedAssignments.push(seedAssignment);\n        }\n      } else if (bye) {\n        const positionAssignment = { drawPosition, bye };\n        positionAssignments.push(positionAssignment);\n      }\n    });\n  }\n\n  const matchUpType =\n    eventType === \"TEAM\" ? legacyMatch.format?.toUpperCase() : eventType;\n\n  const collectionDefinition = tieFormat?.collectionDefinitions.find(\n    (collectionDefinition) => collectionDefinition.matchUpType === matchUpType\n  );\n  const collectionId = collectionDefinition?.collectionId;\n\n  const scoreString = legacyMatch.match?.score || legacyMatch.score || \"\";\n  const reversedScoreString = reverseScore(scoreString) || \"\";\n\n  let winner_index =\n    legacyMatch.match?.winner_index !== undefined &&\n    legacyMatch.match.winner_index;\n  if (![0, 1].includes(parseInt(winner_index)))\n    winner_index = legacyMatch.winner_index;\n  const winner = [0, 1].includes(parseInt(winner_index));\n  const winningSide = (winner && winner_index + 1) || undefined;\n  const scoreStringSide1 = matchTiebreakTODS(\n    !winner || winningSide === 1 ? scoreString : reversedScoreString\n  );\n  const scoreStringSide2 = matchTiebreakTODS(\n    !winner || winningSide === 1 ? reversedScoreString : scoreString\n  );\n  const sets = mocksEngine.parseScoreString({ scoreString: scoreStringSide1 });\n  const score = {\n    scoreStringSide1,\n    scoreStringSide2,\n    sets,\n  };\n\n  const time = scoreString.indexOf(\"TIME\") > 0;\n  const live = scoreString.indexOf(\"LIVE\") > 0;\n  const interrupted = scoreString.indexOf(\"INT\") > 0;\n  const incomplete = scoreString.indexOf(\"INC\") > 0;\n  const walkover = scoreString.indexOf(\"W.O.\") >= 0;\n  const cancelled = scoreString.indexOf(\"CCL\") >= 0;\n  const abandoned = scoreString.indexOf(\"ABD\") >= 0;\n  const defaulted = scoreString.indexOf(\"DEF\") >= 0;\n  const retired = scoreString.indexOf(\"RET\") > 0;\n  const matchUpStatus =\n    (live && matchUpStatusConstants.IN_PROGRESS) ||\n    (interrupted && matchUpStatusConstants.SUSPENDED) ||\n    (incomplete && matchUpStatusConstants.INCOMPLETE) ||\n    (walkover && matchUpStatusConstants.WALKOVER) ||\n    (cancelled && matchUpStatusConstants.NOT_PLAYED) ||\n    (abandoned && matchUpStatusConstants.ABANDONED) ||\n    (defaulted && matchUpStatusConstants.DEFAULTED) ||\n    (retired && matchUpStatusConstants.RETIRED) ||\n    (isBye && matchUpStatusConstants.BYE) ||\n    (winningSide && matchUpStatusConstants.COMPLETED) ||\n    (time && matchUpStatusConstants.COMPLETED) ||\n    (!winningSide && matchUpStatusConstants.TO_BE_PLAYED);\n\n  const timeItems = getTimeItems({ participants, legacyMatch });\n  const matchUp = {\n    matchUpId,\n    score,\n  };\n\n  const drawPositions = sides\n    ?.map((side) => side.drawPosition)\n    .filter((f) => f);\n  if (drawPositions?.length) matchUp.drawPositions = drawPositions;\n\n  if (sides?.length) matchUp.sides = sides;\n  if (matchUpType) matchUp.matchUpType = matchUpType;\n  if (winningSide) matchUp.winningSide = winningSide;\n  if (timeItems?.length) matchUp.timeItems = timeItems;\n  if (collectionId) matchUp.collectionId = collectionId;\n  if (matchUpStatus) matchUp.matchUpStatus = matchUpStatus;\n\n  const format = legacyMatch.match?.score_format || legacyMatch.score_format;\n  const formatCode =\n    format && matchFormatCode.stringify(scoreFormat.jsonTODS(format));\n  matchUpFormat = legacyMatch.match?.matchFormat || matchUpFormat;\n  if (formatCode || matchUpFormat)\n    matchUp.matchUpFormat = formatCode || matchUpFormat;\n\n  const collectionPosition = legacyMatch.sequence;\n  if (collectionPosition) {\n    matchUp.collectionPosition = collectionPosition;\n  }\n  return {\n    matchUp,\n    entries,\n    seedAssignments,\n    positionAssignments,\n    missingParticipants,\n  };\n}\n\nfunction getTimeItems({ participants, legacyMatch }) {\n  const timeItems = [];\n  const schedule = legacyMatch.match?.schedule || legacyMatch.schedule || {};\n  const umpire = legacyMatch.match?.umpire || legacyMatch.umpire;\n\n  if (schedule.luid && schedule.index) {\n    let timeItem = {\n      itemType: \"SCHEDULE.ASSIGNMENT.VENUE\",\n      itemValue: schedule.luid,\n      timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n    };\n    timeItems.push(timeItem);\n\n    timeItem = {\n      itemType: \"SCHEDULE.ASSIGNMENT.COURT\",\n      itemValue: `${schedule.luid}|${parseInt(schedule.index) - 1}`,\n      timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n    };\n    timeItems.push(timeItem);\n  }\n\n  if (schedule.day) {\n    const timeItem = {\n      itemType: \"SCHEDULED.DATE\",\n      itemValue: schedule.day,\n      timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n    };\n    timeItems.push(timeItem);\n\n    if (schedule.start) {\n      const startTime = properTime(schedule.start);\n      const startDateTime = `${dateFx.formatDate(schedule.day)}T${startTime}`;\n      const timeItem = {\n        itemType: \"SCHEDULE.TIME.START\",\n        itemValue: new Date(startDateTime).toISOString(),\n        timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n      };\n      timeItems.push(timeItem);\n    }\n\n    if (schedule.end) {\n      const endTime = properTime(schedule.end);\n      const endDateTime = `${dateFx.formatDate(schedule.day)}T${endTime}`;\n      const timeItem = {\n        itemType: \"SCHEDULE.TIME.END\",\n        itemValue: new Date(endDateTime).toISOString(),\n        timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n      };\n      timeItems.push(timeItem);\n    }\n  }\n\n  if (schedule.time) {\n    const itemValue = properTime(schedule.time);\n    const timeItem = {\n      itemType: \"SCHEDULE.TIME.SCHEDULED\",\n      itemValue,\n      timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n    };\n    timeItems.push(timeItem);\n  }\n\n  if (umpire) {\n    const tournamentOfficials = participants?.filter(\n      (participant) =>\n        participant.participantType === participantConstants.INDIVIDUAL &&\n        participant.participantRole === participantRoles.OFFICIAL\n    );\n    const official = tournamentOfficials.find(\n      (official) => official.name === umpire\n    );\n    const itemValue = official?.participantId;\n    const timeItem = {\n      itemType: \"SCHEDULE.ASSIGNMENT.OFFICIAL\",\n      itemValue,\n      timeStamp: new Date().toISOString(), // TODO: should be the start date of the tournament\n    };\n    if (itemValue) timeItems.push(timeItem);\n  }\n\n  return timeItems;\n}\n\nfunction properTime(time) {\n  const military = dateFx.militaryTime(time);\n  const zeroPad = (number) => (number.toString()[1] ? number : \"0\" + number);\n  return military\n    .split(\":\")\n    .map((part) => zeroPad(part))\n    .join(\":\");\n}\n\nfunction matchTiebreakTODS(score = \"\") {\n  return score\n    .split(\" \")\n    .map((set) => {\n      return set.includes(\"/\") ? matchTiebreak(set) : set;\n    })\n    .join(\" \");\n\n  function matchTiebreak(set) {\n    return `[${set.split(\"/\").join(\"-\")}]`;\n  }\n}\n\nfunction reverseScore(score, split = \" \") {\n  let irreversible = null;\n  if (score) {\n    let reversed = score.split(split).map(parseSet).join(split);\n    let result = irreversible ? `${irreversible} ${reversed}` : reversed;\n    return result;\n  }\n\n  function parseSet(set) {\n    let divider = set.indexOf(\"/\") > 0 ? \"/\" : \"-\";\n    let set_scores = set\n      .split(divider)\n      .map(parseSetScore)\n      .reverse()\n      .filter((f) => f);\n    let set_games = set_scores.map((s) => s.games);\n    let tb_scores = set_scores.map((s) => s.tiebreak).filter((f) => f);\n    let tiebreak = tb_scores.length === 1 ? `(${tb_scores[0]})` : \"\";\n    let set_score =\n      tb_scores.length < 2\n        ? set_games.join(divider)\n        : set_games.map((s, i) => `${s}(${tb_scores[i]})`).join(divider);\n    return `${set_score}${tiebreak}`;\n  }\n\n  function parseSetScore(set) {\n    let ss = /(\\d+)/;\n    let sst = /(\\d+)\\((\\d+)\\)/;\n    if (sst.test(set))\n      return { games: sst.exec(set)[1], tiebreak: sst.exec(set)[2] };\n    if (ss.test(set)) return { games: ss.exec(set)[1] };\n    irreversible = set;\n    return undefined;\n  }\n}\n","import {\n  eventConstants,\n  genderConstants,\n  drawDefinitionConstants,\n} from \"tods-competition-factory\";\n\nconst surfaceCategoryMap = {\n  C: \"CLAY\",\n  H: \"HARD\",\n  G: \"GRASS\",\n  R: \"CARPET\",\n};\n\nexport function getSurface(element) {\n  return surfaceCategoryMap[element?.surface];\n}\n\nexport function getIndoorOutdoor(element) {\n  return (\n    (element?.inout === \"o\" && \"OUTDOOR\") ||\n    (element?.inout === \"i\" && \"INDOOR\")\n  );\n}\n\nexport function intersection(a, b) {\n  return a\n    .filter((n) => b.indexOf(n) !== -1)\n    .filter((e, i, c) => c.indexOf(e) === i);\n}\n\nexport function getAgeCategoryCode(category) {\n  const categoryCodeMap = {\n    U10: \"10U\",\n    U12: \"12U\",\n    U14: \"14U\",\n    U16: \"16U\",\n    U18: \"18U\",\n    10: \"10U\",\n    12: \"12U\",\n    14: \"14U\",\n    16: \"16U\",\n    18: \"18U\",\n    Senior: \"O18\",\n  };\n\n  return categoryCodeMap[category];\n}\n\nexport function getMatchUpType(format) {\n  return (\n    ([\"S\", \"SINGLES\"].includes(format.toUpperCase()) &&\n      eventConstants.SINGLES) ||\n    ([\"D\", \"DOUBLES\"].includes(format.toUpperCase()) && eventConstants.DOUBLES)\n  );\n}\n\nexport function getGender(value) {\n  if (!value) return genderConstants.MIXED;\n  if ([\"F\", \"FEMALE\", \"W\", \"WOMAN\"].includes(value.toUpperCase()))\n    return genderConstants.FEMALE;\n  if ([\"M\", \"MALE\", \"MAN\"].includes(value.toUpperCase()))\n    return genderConstants.MALE;\n  return genderConstants.MIXED;\n}\n\nexport function getStage({ legacyEvent }) {\n  const stageMap = {\n    E: drawDefinitionConstants.MAIN,\n    Q: drawDefinitionConstants.QUALIFYING,\n    S: drawDefinitionConstants.MAIN,\n    C: drawDefinitionConstants.CONSOLATION,\n    P: drawDefinitionConstants.PLAY_OFF,\n    A: drawDefinitionConstants.MAIN,\n  };\n\n  if (legacyEvent.draw_type === \"R\") {\n    if (Object.keys(legacyEvent.links || {}).includes(\"E\")) {\n      return drawDefinitionConstants.QUALIFYING;\n    } else {\n      return drawDefinitionConstants.MAIN;\n    }\n  }\n\n  return stageMap[legacyEvent.draw_type];\n}\n","export const typeCheck = (function () {\n  let tc = {};\n\n  const FEED = \"feed\";\n  const SINGLES = \"singles\";\n  const DOUBLES = \"doubles\";\n  const BACKDRAW = \"backdraw\";\n\n  tc.isActiveEvent = ({ e }) => e && e.active;\n  tc.isAdHoc = ({ e }) => e && e.draw_type && e.draw_type === \"A\";\n  tc.isPlayoff = ({ e }) => e && e.draw_type && e.draw_type === \"P\";\n  tc.isQualifying = ({ e }) => e && e.draw_type && e.draw_type === \"Q\";\n  tc.isRoundRobin = ({ e }) => e && e.draw_type && e.draw_type === \"R\";\n  tc.isConsolation = ({ e }) => e && e.draw_type && e.draw_type === \"C\";\n  tc.isElimination = ({ e }) => e && e.draw_type && e.draw_type === \"E\";\n  tc.hasEliminationStructure = ({ e }) =>\n    e && e.draw_type && [\"E\", \"Q\", \"C\", \"P\", \"S\"].indexOf(e.draw_type) >= 0;\n  tc.isCompass = ({ e }) =>\n    e &&\n    ((e.draw_type && [\"S\", \"O\"].indexOf(e.draw_type) >= 0) ||\n      e.direction ||\n      (e.draw && e.draw.compass));\n\n  tc.isFeedIn = ({ e, value }) =>\n    (value && value === FEED) || (e && e.structure && e.structure === FEED);\n  tc.isBackdraw = ({ e, value }) =>\n    (value && value === BACKDRAW) ||\n    (e && e.structure && e.structure === BACKDRAW);\n\n  tc.hasRoundNames = ({ e }) =>\n    e && e.draw_type && [\"E\", \"S\", \"C\", \"O\"].indexOf(e.draw_type) >= 0;\n\n  tc.isConsolationFeedIn = ({ e }) =>\n    tc.isConsolation({ e }) && tc.isFeedIn({ e });\n  tc.isConsolationBackdraw = ({ e }) =>\n    tc.isConsolation({ e }) && tc.isBackdraw({ e });\n  tc.isConsolationFixed = ({ e }) =>\n    tc.isConsolation({ e }) && (tc.isFeedIn({ e }) || tc.isBackdraw({ e }));\n\n  tc.isSingles = ({ e, match }) => {\n    if (e)\n      return (\n        e.format && (e.format === \"S\" || e.format.toLowerCase() === SINGLES)\n      );\n    if (match)\n      return (\n        match.format &&\n        (match.format === \"S\" || match.format.toLowerCase() === SINGLES)\n      );\n  };\n  tc.isDoubles = ({ e, match }) => {\n    if (e)\n      return (\n        e.format && (e.format === \"D\" || e.format.toLowerCase() === DOUBLES)\n      );\n    if (match)\n      return (\n        match.format &&\n        (match.format === \"D\" || match.format.toLowerCase() === DOUBLES)\n      );\n  };\n\n  tc.isTeam = ({ tournament, e }) => {\n    if (tournament && tournament.type)\n      return [\"team\", \"dual\"].indexOf(tournament.type) >= 0;\n    let dual_draw = e && e.draw && e.draw.dual_matches;\n    return e && (dual_draw || e.event_type === \"dual\");\n  };\n\n  tc.isPreRound = ({ env, e }) => {\n    let qualifying_bracket_seeding =\n      env && env.drawFx && env.drawFx.qualifying_bracket_seeding;\n    return (\n      tc.isQualifying({ e }) &&\n      e.approved &&\n      e.approved.length &&\n      +e.qualifiers === e.draw_size / 2 &&\n      qualifying_bracket_seeding\n    );\n  };\n\n  return tc;\n})();\n","export function courtData(tournament, luid, max_matches_per_court = 14) {\n  let courts = [];\n  safeArr(tournament.locations).forEach((l) => {\n    let identifiers = l.identifiers ? l.identifiers.split(\",\") : [];\n    if (!luid || luid === l.luid) {\n      range(1, +l.courts + 1).forEach((index) => {\n        let identifier = identifiers[index - 1] || index;\n        let court = {\n          luid: l.luid,\n          name: `${l.abbreviation} ${identifier}`,\n          availability: range(1, max_matches_per_court + 1),\n          index,\n        };\n        courts.push(court);\n      });\n    }\n  });\n  return courts;\n}\n\nexport function ctuuid(schedule) {\n  return schedule ? `${schedule.luid}|${schedule.index}` : \"\";\n}\n\nfunction safeArr(x) {\n  return (\n    (Array.isArray(x) && x) ||\n    (typeof x === \"object\" && Object.keys(x).map((k) => x[k])) ||\n    []\n  );\n}\nfunction range(start, end) {\n  return Array.from({ length: end - start }, (v, k) => k + start);\n}\n","import { scoreFormat } from \"./scoreFormat\";\nimport { matchFormatCode } from \"./matchFormatCode\";\n\nexport const scoreFx = (function () {\n  let fx = {};\n\n  function validInt(value, invalid) {\n    let result = parseInt(value);\n    return isNaN(result) ? invalid : result;\n  }\n\n  // target is an object which *must* have all keys defined.\n  // preference is given to the *first* object processed\n  function assignKeys({ source = {}, objects = [] }) {\n    let target = Object.assign({}, source);\n    if (objects && !Array.isArray(objects)) objects = [objects];\n    objects = objects.filter((f) => f);\n    objects.forEach((o) => {\n      if (typeof o !== \"object\") return;\n      let keys = Object.keys(o);\n      keys.forEach(\n        (k) => (target[k] = target[k] !== undefined ? target[k] : o[k])\n      );\n    });\n    return target;\n  }\n\n  fx.setsToWin = (best_of) => (best_of && Math.ceil(best_of / 2)) || 1;\n  fx.tiebreakTo = (o, isFinalSet) => {\n    let setTiebreakTo =\n      o &&\n      o.setFormat &&\n      o.setFormat.tiebreakFormat &&\n      o.setFormat.tiebreakFormat.tiebreakTo;\n    let finalSetTiebreakTo =\n      o &&\n      o.finalSetFormat &&\n      o.finalSetFormat.tiebreakFormat &&\n      o.finalSetFormat.tiebreakFormat.tiebreakTo;\n    return isFinalSet ? finalSetTiebreakTo : setTiebreakTo;\n  };\n\n  fx.matchFormat = matchFormat;\n  function matchFormat(matchFormat) {\n    return (matchFormat || \"SET3-S:6/TB7\").slice(3);\n  }\n\n  fx.getExistingScores = ({ match }) => {\n    if (!match || !match.score) return undefined;\n    let es = convertStringScore({\n      string_score: match.score,\n      winner_index: match.winner_index,\n      matchFormat: match.matchFormat,\n    });\n    return es;\n  };\n\n  fx.generateMatchFormat = ({ cfg_obj }) => {\n    let bestof = cfg_obj.bestof.ddlb.getValue();\n    let max_sets = validInt(bestof);\n    let sets_to_win = scoreFx.setsToWin(max_sets);\n    let score_format = {\n      max_sets,\n      sets_to_win,\n      games_for_set: validInt(cfg_obj.setsto.ddlb.getValue()),\n      tiebreaks_at: validInt(cfg_obj.tiebreaksat.ddlb.getValue()) || \"\", // only option that can be 'none'\n      tiebreak_to: validInt(cfg_obj.tiebreaksto.ddlb.getValue()),\n      supertiebreak_to: validInt(cfg_obj.supertiebreakto.ddlb.getValue()),\n      final_set_supertiebreak:\n        cfg_obj.finalset.ddlb.getValue() === \"N\" ? false : true,\n    };\n\n    let matchFormat = matchFormatCode.stringify(\n      scoreFormat.jsonTODS(score_format)\n    );\n\n    return { matchFormat, score_format };\n  };\n\n  fx.getScoringFormat = ({ e, match }) => {\n    let format =\n      (match && match.format) || (e.format === \"D\" ? \"doubles\" : \"singles\");\n\n    let objects = [\n      match && match.score_format,\n      match && match.match && match.match.score_format,\n      e.scoring_format && e.scoring_format[format],\n      e.score_format,\n    ];\n\n    let score_format = assignKeys({ objects });\n\n    return score_format;\n  };\n\n  fx.defaultMatchFormat = ({ format, category, env }) => {\n    let matchFormats = env.scoreboard.matchFormats;\n    let formats = { S: \"singles\", D: \"doubles\" };\n    if (Object.keys(formats).indexOf(format) >= 0) format = formats[format];\n    if (\n      format &&\n      category &&\n      matchFormats.categories[category] &&\n      matchFormats.categories[category][format]\n    )\n      return matchFormats.categories[category][format];\n    if (format && matchFormats[format]) return matchFormats[format];\n    return matchFormats.singles;\n  };\n\n  fx.convertStringScore = convertStringScore;\n  function convertStringScore({\n    string_score,\n    winner_index,\n    split = \" \",\n    matchFormat,\n  }) {\n    if (!string_score) return [];\n\n    string_score = winner_index ? reverseScore(string_score) : string_score;\n\n    let outcome = null;\n    let ss = /(\\d+)/;\n    let sst = /(\\d+)\\((\\d+)\\)/;\n    let match_format = matchFormatCode.parse(matchFormat);\n\n    let sets = string_score\n      .split(split)\n      .filter((f) => f)\n      .map((set) => {\n        if (set.indexOf(\"/\") > 0) {\n          // look for supertiebreak scores using #/# format\n          let scores = set\n            .split(\"/\")\n            .map((m) => (ss.exec(m) ? { games: +ss.exec(m)[1] } : undefined))\n            .filter((f) => f);\n          if (scores.length === 2) return scores;\n        }\n\n        // uglifier doesn't work if variable is undefined\n        let tbscore = null;\n        let scores = set.split(\"-\").map((m) => {\n          let score;\n          if (sst.test(m)) {\n            tbscore = +sst.exec(m)[2];\n            score = { games: +sst.exec(m)[1] };\n          } else if (ss.test(m)) {\n            score = { games: +ss.exec(m)[1] };\n          } else {\n            outcome = m;\n          }\n          return score || undefined;\n        });\n\n        // filter out undefined scores\n        scores = scores.filter((f) => f);\n\n        // add spacer for score without tiebreak score\n        if (tbscore !== null) {\n          let min_games = Math.min(...scores.map((s) => s.games));\n          scores.forEach((sf) => {\n            if (+sf.games === +min_games) {\n              sf.tiebreak = tbscore;\n            } else {\n              sf.spacer = tbscore;\n            }\n          });\n        }\n\n        return scores;\n      });\n\n    // filter out sets without two scores\n    sets = sets.filter((scores) => scores && scores.length === 2);\n\n    // determine if set is supertiebreak\n    sets.forEach((st, i) => {\n      let set_format =\n        match_format && (match_format.finalSetFormat || match_format.setFormat);\n      let supertiebreak_to =\n        set_format &&\n        set_format.tiebreakSet &&\n        set_format.tiebreakSet.tiebreakTo;\n\n      if (st[0].games >= supertiebreak_to || st[1].games >= supertiebreak_to) {\n        st[0].supertiebreak = st[0].games;\n        st[1].supertiebreak = st[1].games;\n        delete st[0].games;\n        delete st[1].games;\n      }\n    });\n\n    if (winner_index !== undefined) {\n      sets.winner_index = winner_index;\n    }\n\n    if (outcome) {\n      if (outcome === \"Cancelled\") sets.cancelled = true;\n      if (outcome === \"Abandoned\") sets.abandoned = true;\n      if (outcome === \"INC.\") sets.incomplete = true;\n      if (outcome === \"INT.\") sets.interrupted = true;\n      if (outcome === \"LIVE\") sets.live = true;\n      if (outcome === \"TIME\") sets.time = true;\n      if (outcome === \"DEF.\") sets.default = true;\n      if (outcome === \"W.O.\") sets.walkover = true;\n\n      if (!sets.length) return sets;\n\n      // passing additional detail from string parse...\n      if (winner_index !== undefined) {\n        // outcomes are attributed to loser...\n        sets[sets.length - 1][1 - winner_index].outcome = outcome;\n        // and set as attribute on set\n        sets[sets.length - 1].outcome = outcome;\n        sets.outome = outcome;\n      }\n    }\n\n    return sets;\n  }\n\n  fx.reverseScore = reverseScore;\n  function reverseScore(score, split = \" \") {\n    let irreversible = null;\n    if (score) {\n      let reversed = score.split(split).map(parseSet).join(split);\n      let result = irreversible ? `${irreversible} ${reversed}` : reversed;\n      return result;\n    }\n\n    function parseSet(set) {\n      let divider = set.indexOf(\"/\") > 0 ? \"/\" : \"-\";\n      let set_scores = set\n        .split(divider)\n        .map(parseSetScore)\n        .reverse()\n        .filter((f) => f);\n      let set_games = set_scores.map((s) => s.games);\n      let tb_scores = set_scores.map((s) => s.tiebreak).filter((f) => f);\n      let tiebreak = tb_scores.length === 1 ? `(${tb_scores[0]})` : \"\";\n      let set_score =\n        tb_scores.length < 2\n          ? set_games.join(divider)\n          : set_games.map((s, i) => `${s}(${tb_scores[i]})`).join(divider);\n      return `${set_score}${tiebreak}`;\n    }\n\n    function parseSetScore(set) {\n      let ss = /(\\d+)/;\n      let sst = /(\\d+)\\((\\d+)\\)/;\n      if (sst.test(set))\n        return { games: sst.exec(set)[1], tiebreak: sst.exec(set)[2] };\n      if (ss.test(set)) return { games: ss.exec(set)[1] };\n      irreversible = set;\n      return undefined;\n    }\n  }\n\n  return fx;\n})();\n","/**\n * Fast UUID generator, RFC4122 version 4 compliant.\n * @author Jeff Ward (jcward.com).\n * @license MIT license\n * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n * ... and ...\n * https://codepen.io/avesus/pen/wgQmaV\n **/\nexport const UUID = (function () {\n  let self = {};\n  let lut = [];\n  for (var i = 0; i < 256; i++) {\n    lut[i] = (i < 16 ? \"0\" : \"\") + i.toString(16);\n  }\n\n  let getWindow = () => {\n    try {\n      return window;\n    } catch (e) {\n      return undefined;\n    }\n  };\n\n  let formatUuid = ({ d0, d1, d2, d3 }) =>\n    // eslint-disable-next-line no-mixed-operators\n    lut[d0 & 0xff] +\n    lut[(d0 >> 8) & 0xff] +\n    lut[(d0 >> 16) & 0xff] +\n    lut[(d0 >> 24) & 0xff] +\n    \"-\" +\n    // eslint-disable-next-line no-mixed-operators\n    lut[d1 & 0xff] +\n    lut[(d1 >> 8) & 0xff] +\n    \"-\" +\n    // eslint-disable-next-line no-mixed-operators\n    lut[((d1 >> 16) & 0x0f) | 0x40] +\n    lut[(d1 >> 24) & 0xff] +\n    \"-\" +\n    // eslint-disable-next-line no-mixed-operators\n    lut[(d2 & 0x3f) | 0x80] +\n    lut[(d2 >> 8) & 0xff] +\n    \"-\" +\n    // eslint-disable-next-line no-mixed-operators\n    lut[(d2 >> 16) & 0xff] +\n    lut[(d2 >> 24) & 0xff] +\n    // eslint-disable-next-line no-mixed-operators\n    lut[d3 & 0xff] +\n    lut[(d3 >> 8) & 0xff] +\n    // eslint-disable-next-line no-mixed-operators\n    lut[(d3 >> 16) & 0xff] +\n    lut[(d3 >> 24) & 0xff];\n\n  let getRandomValuesFunc =\n    getWindow() && getWindow().crypto && getWindow().crypto.getRandomValues\n      ? () => {\n          const dvals = new Uint32Array(4);\n          getWindow().crypto.getRandomValues(dvals);\n          return {\n            d0: dvals[0],\n            d1: dvals[1],\n            d2: dvals[2],\n            d3: dvals[3],\n          };\n        }\n      : () => ({\n          d0: (Math.random() * 0x100000000) >>> 0,\n          d1: (Math.random() * 0x100000000) >>> 0,\n          d2: (Math.random() * 0x100000000) >>> 0,\n          d3: (Math.random() * 0x100000000) >>> 0,\n        });\n\n  self.new = () => formatUuid(getRandomValuesFunc());\n\n  self.idGen = () => `u_${self.generate()}`;\n  self.generate = function () {\n    var d0 = (Math.random() * 0xffffffff) | 0;\n    var d1 = (Math.random() * 0xffffffff) | 0;\n    var d2 = (Math.random() * 0xffffffff) | 0;\n    var d3 = (Math.random() * 0xffffffff) | 0;\n    // eslint-disable-next-line no-mixed-operators\n    return (\n      lut[d0 & 0xff] +\n      lut[(d0 >> 8) & 0xff] +\n      lut[(d0 >> 16) & 0xff] +\n      lut[(d0 >> 24) & 0xff] +\n      \"-\" +\n      // eslint-disable-next-line no-mixed-operators\n      lut[d1 & 0xff] +\n      lut[(d1 >> 8) & 0xff] +\n      \"-\" +\n      lut[((d1 >> 16) & 0x0f) | 0x40] +\n      lut[(d1 >> 24) & 0xff] +\n      \"-\" +\n      // eslint-disable-next-line no-mixed-operators\n      lut[(d2 & 0x3f) | 0x80] +\n      lut[(d2 >> 8) & 0xff] +\n      \"-\" +\n      lut[(d2 >> 16) & 0xff] +\n      lut[(d2 >> 24) & 0xff] +\n      // eslint-disable-next-line no-mixed-operators\n      lut[d3 & 0xff] +\n      lut[(d3 >> 8) & 0xff] +\n      lut[(d3 >> 16) & 0xff] +\n      lut[(d3 >> 24) & 0xff]\n    );\n  };\n\n  return self;\n})();\n","import * as d3 from \"d3\";\n\n// CourtHive-common-core\nimport { UUID } from \"./UUID\";\nimport { scoreFx } from \"./scoreFx\";\nimport { matchFormatCode } from \"./matchFormatCode\";\n\n/* To convert tmx 1.0 draw into tmx 2.0 draw nuids need to be added to all\n * nodes and array of opponent ids needs to be added to deepest nodes.\n */\n\nfunction playersHash(players) {\n  return players\n    .map((p) => p && p.id)\n    .filter((f) => f)\n    .sort()\n    .join(\"-\");\n}\n\nexport function drawFx(opts) {\n  var fx = {};\n\n  let numArr = (count) => [...Array(count)].map((_, i) => i);\n  let unique = (arr) => arr.filter((item, i, s) => s.lastIndexOf(item) === +i);\n  let range = (start, end) =>\n    Array.from({ length: end - start }, (v, k) => k + start);\n  let indices = (val, arr) =>\n    arr.reduce((a, e, i) => {\n      if (e === val) a.push(i);\n      return a;\n    }, []);\n  let occurrences = (val, arr) =>\n    arr.reduce((r, val) => {\n      r[val] = 1 + r[val] || 1;\n      return r;\n    }, {})[val] || 0;\n  let intersection = (a, b) =>\n    a\n      .filter((n) => b.indexOf(n) !== -1)\n      .filter((e, i, c) => c.indexOf(e) === i);\n  let randomPop = (array) =>\n    array.length\n      ? array.splice(Math.floor(Math.random() * array.length), 1)[0]\n      : undefined;\n  let subSort = (arr, i, n, sortFx) =>\n    [].concat(\n      ...arr.slice(0, i),\n      ...arr.slice(i, i + n).sort(sortFx),\n      ...arr.slice(i + n, arr.length)\n    );\n\n  var standard_draws = [2, 4, 8, 16, 32, 64, 128, 256, 512];\n  // removed 224 because compressed draws blowing up beyond 128\n  var draw_sizes = [2, 4, 8, 12, 16, 24, 32, 48, 64, 96, 128, 256, 512];\n  var validDrawSize = (players) => draw_sizes.indexOf(players) >= 0;\n\n  var o = {\n    rr_h2h_priority: false,\n    compressed_draw_formats: true,\n    compressed: { byes_adjacent_to_seeds: false },\n    seedBlocks: [[1], [2], [3, 4], [5, 8], [9, 16], [17, 32], [33, 64]],\n    seed_limits: [\n      [0, 0],\n      [4, 2],\n      [11, 4],\n      [21, 8],\n      [41, 16],\n      [97, 32],\n      [193, 64],\n    ],\n    bye_placement: {\n      8: [2, 7, 5],\n      16: [2, 15, 11, 6, 7, 10, 14],\n      32: [2, 31, 23, 10, 15, 18, 26, 7, 6, 27, 19, 14, 11, 22, 30],\n      64: [\n        2,\n        63,\n        47,\n        18,\n        31,\n        34,\n        50,\n        15,\n        10,\n        55,\n        39,\n        26,\n        23,\n        42,\n        58,\n        7,\n        5,\n        60,\n        44,\n        21,\n        28,\n        37,\n        53,\n        12,\n        13,\n        52,\n        36,\n        29,\n        20,\n        45,\n        61,\n      ],\n      128: [\n        2,\n        127,\n        31,\n        34,\n        63,\n        66,\n        95,\n        98,\n        15,\n        18,\n        47,\n        50,\n        79,\n        82,\n        111,\n        114,\n        7,\n        10,\n        23,\n        26,\n        39,\n        42,\n        55,\n        58,\n        71,\n        74,\n        87,\n        90,\n        103,\n        106,\n        119,\n        122,\n      ],\n      256: [\n        2,\n        255,\n        63,\n        66,\n        127,\n        130,\n        191,\n        194,\n        31,\n        34,\n        95,\n        98,\n        159,\n        162,\n        223,\n        226,\n        15,\n        18,\n        47,\n        50,\n        79,\n        82,\n        111,\n        114,\n        143,\n        146,\n        175,\n        178,\n        207,\n        210,\n        239,\n        242,\n        7,\n        10,\n        23,\n        26,\n        39,\n        42,\n        55,\n        58,\n        71,\n        74,\n        87,\n        90,\n        103,\n        106,\n        119,\n        122,\n        135,\n        138,\n        151,\n        154,\n        167,\n        170,\n        183,\n        186,\n        199,\n        202,\n        215,\n        218,\n        231,\n        234,\n        247,\n        250,\n      ],\n    },\n    seedPositions: {\n      1: [[\"1\", \"0\"]],\n      2: [[\"0\", \"1\"]],\n      3: [\n        [\"1\", \".250\"],\n        [\"0\", \".750\"],\n      ],\n      5: [\n        [\"0\", \".250\"],\n        [\"0\", \".500\"],\n        [\"1\", \".500\"],\n        [\"1\", \".750\"],\n      ],\n      9: [\n        [\"1\", \".125\"],\n        [\"0\", \".375\"],\n        [\"1\", \".625\"],\n        [\"0\", \".875\"],\n        [\"0\", \".125\"],\n        [\"1\", \".375\"],\n        [\"0\", \".625\"],\n        [\"1\", \".875\"],\n      ],\n      13: [],\n      17: [\n        [\"1\", \".0625\"],\n        [\"0\", \".1875\"],\n        [\"1\", \".3125\"],\n        [\"0\", \".4375\"],\n        [\"1\", \".5625\"],\n        [\"0\", \".6875\"],\n        [\"1\", \".8125\"],\n        [\"0\", \".9375\"],\n        [\"0\", \".0625\"],\n        [\"1\", \".1875\"],\n        [\"0\", \".3125\"],\n        [\"1\", \".4375\"],\n        [\"0\", \".5625\"],\n        [\"1\", \".6875\"],\n        [\"0\", \".8125\"],\n        [\"1\", \".9375\"],\n      ],\n      25: [],\n      33: [\n        [\"1\", \".03125\"],\n        [\"0\", \".09375\"],\n        [\"1\", \".15625\"],\n        [\"0\", \".21875\"],\n        [\"1\", \".28125\"],\n        [\"0\", \".34375\"],\n        [\"1\", \".40625\"],\n        [\"0\", \".46875\"],\n        [\"1\", \".53125\"],\n        [\"0\", \".59375\"],\n        [\"1\", \".65625\"],\n        [\"0\", \".71875\"],\n        [\"1\", \".78125\"],\n        [\"0\", \".84375\"],\n        [\"1\", \".90625\"],\n        [\"0\", \".96875\"],\n        [\"0\", \".03125\"],\n        [\"1\", \".09375\"],\n        [\"0\", \".15625\"],\n        [\"1\", \".21875\"],\n        [\"0\", \".28125\"],\n        [\"1\", \".34375\"],\n        [\"0\", \".40625\"],\n        [\"1\", \".46875\"],\n        [\"0\", \".53125\"],\n        [\"1\", \".59375\"],\n        [\"0\", \".65625\"],\n        [\"1\", \".71875\"],\n        [\"0\", \".78125\"],\n        [\"1\", \".84375\"],\n        [\"0\", \".90625\"],\n        [\"1\", \".96875\"],\n      ],\n      49: [],\n    },\n    separation: { team: true },\n  };\n\n  if (opts) keyWalk(opts, o);\n\n  fx.options = (options) => {\n    if (!options) return o;\n    keyWalk(options, o);\n  };\n\n  fx.acceptedDrawSizes = acceptedDrawSizes;\n  function acceptedDrawSizes({ num_players, standardSizes, forceCompressed }) {\n    if (!num_players || num_players < 2) return 0;\n\n    let d = 0;\n    while (draw_sizes[d] < num_players) d += 1;\n\n    let s = 0;\n    while (standard_draws[s] < num_players) s += 1;\n\n    if (standardSizes) return standard_draws[s];\n\n    // otherwise check the settings for desired draw structure\n    // added 128 limit because compressed draws > 128 blowing up\n    return (forceCompressed || o.compressed_draw_formats) && num_players <= 128\n      ? draw_sizes[d]\n      : standard_draws[s];\n  }\n\n  fx.standardDrawSize = standardDrawSize;\n  function standardDrawSize(num_players) {\n    let i = 0;\n    while (standard_draws[i] < num_players) i += 1;\n    return standard_draws[i];\n  }\n\n  fx.treeDrawMatchOrder = treeDrawMatchOrder;\n  function treeDrawMatchOrder(draw) {\n    let mtz = matches(draw);\n    return mtz\n      .filter((m) => m.match)\n      .sort((a, b) => drawPosition(a) - drawPosition(b))\n      .map((m) => m.match.muid);\n    function drawPosition(match) {\n      if (!match.teams || !Array.isArray(match.teams) || !match.teams.length)\n        return 1000;\n      let draw_position = match.teams.reduce(\n        (p, c) => (c && c[0] && c[0].draw_position) || p,\n        undefined\n      );\n      return draw_position || 1000;\n    }\n  }\n\n  fx.bracketMatches = bracketMatches;\n  function bracketMatches(draw, bracket_index) {\n    if (!draw || !draw.brackets) return [];\n    let bracket = draw.brackets[bracket_index];\n\n    let teamsHash = (teams) => {\n      return teams\n        .map((team) =>\n          team\n            .map((p) => p.id)\n            .sort()\n            .join(\"-\")\n        )\n        .sort()\n        .join(\"-\");\n    };\n    let uniqueTeam = (arr, m) => {\n      if (arr.map(teamsHash).indexOf(teamsHash(m)) < 0) arr.push(m);\n      return arr;\n    };\n\n    pruneDefunctMatches();\n    findMissingMatches();\n\n    return bracket.matches;\n\n    function pruneDefunctMatches() {\n      // to support legacy brackets\n      if (!bracket.teams) {\n        bracket.teams = bracket.players.map((p) => [p]);\n      }\n\n      // get an array of all match_ups:\n      let match_ups = [].concat(\n        ...bracket.teams\n          .map((team) => teamMatchups(team))\n          .map((matchup) => matchup.map((teams) => teams.map(playersHash)))\n      );\n\n      let existing_match_ups = bracket.matches.map((match) =>\n        match.teams ? match.teams.map(playersHash) : []\n      );\n      let defunct = existing_match_ups.filter(\n        (emu) =>\n          !match_ups.reduce(\n            (p, c) => (emu && c && intersection(emu, c).length === 2) || p,\n            false\n          )\n      );\n\n      bracket.matches = bracket.matches.filter((match) => {\n        let pairing = match.teams ? match.teams.map(playersHash) : [];\n        let obsolete = defunct.reduce(\n          (p, c) => intersection(pairing, c).length === 2 || p,\n          false\n        );\n        return !obsolete;\n      });\n    }\n\n    function findMissingMatches() {\n      []\n        .concat(...bracket.teams.map(teamMissingMatches))\n        .reduce(uniqueTeam, [])\n        .forEach(addTeamMatch);\n    }\n\n    function addTeamMatch(teams) {\n      let players = [].concat(...teams);\n      let match = {\n        teams,\n        players,\n        round_name: \"RR\",\n        bracket: bracket_index,\n        ids: players.map((p) => p.id || p.id),\n      };\n      bracket.matches.push(match);\n    }\n\n    function teamMissingMatches(team) {\n      let team_matchups = teamMatchups(team);\n      let matches_hash = bracket.matches\n        .filter((m) => m.teams)\n        .map((m) => teamsHash(m.teams));\n      let missing = team_matchups.filter((tm) => {\n        let index = matches_hash.indexOf(teamsHash(tm));\n        return index < 0;\n      });\n      return missing;\n    }\n\n    function teamMatchups(team) {\n      let opponents = bracket.teams.filter(\n        (t) => playersHash(t) !== playersHash(team)\n      );\n      let matchups = opponents.map((o) => [team, o]);\n      return matchups;\n    }\n  }\n\n  fx.roundRobinRounds = roundRobinRounds;\n  function roundRobinRounds({ event }) {\n    let draw = event && event.draw;\n    if (!draw || !draw.brackets || !draw.brackets.length) return;\n\n    let rounds = [];\n    let rrbr = draw.brackets.map(bracketRounds);\n    let qualifying = event && event.links && event.links.E;\n\n    let max_rounds = Math.max(...rrbr.map((r) => r.length));\n    for (let r = 0; r < max_rounds; r++) {\n      rounds.push(\n        rrbr\n          .map((br, b) => ({\n            bracket: b,\n            matchups: bracketMatchups(b, br[r], r),\n          }))\n          .filter((f) => f.matchups)\n      );\n    }\n    rounds.forEach((round, i) => {\n      round.forEach((bracket) => {\n        bracket.matchups.forEach((matchup) => {\n          matchup.round = i + 1;\n          matchup.round_name = `RR${qualifying ? \"Q\" : \"\"}${i + 1}`;\n        });\n      });\n    });\n\n    return rounds;\n\n    function bracketMatchups(bracket_index, matchups /*, round*/) {\n      if (!matchups) return;\n      let matches = draw.brackets[bracket_index].matches;\n      let matchhashes = matchups.map((m) => m.sort().join(\"|\"));\n      let result = matches.filter(\n        (m) =>\n          matchhashes.indexOf(\n            m.players\n              .map((p) => p.draw_position)\n              .sort()\n              .join(\"|\")\n          ) >= 0\n      );\n      return result;\n    }\n  }\n\n  fx.bracketRounds = bracketRounds;\n  function bracketRounds(bracket) {\n    if (!bracket || !bracket.matches || !bracket.matches.length) return [];\n    return calcBracketRounds(bracket);\n  }\n\n  // calculate rounds for a given number of round robin opponents\n  function calcBracketRounds(bracket) {\n    let opponents = bracket.players.length;\n    let numArr = (count) => [...Array(count)].map((_, i) => i);\n    let positions = numArr(2 * Math.round(opponents / 2) + 1).slice(1);\n    let rounds = numArr(positions.length - 1).map(() => []);\n    let a_row = positions.slice(0, positions.length / 2);\n    let b_row = positions.slice(positions.length / 2);\n    positions.slice(1).forEach((p, i) => {\n      a_row.forEach((a, j) => {\n        rounds[i].push([a_row[j], b_row[j]]);\n      });\n      let a_head = a_row.shift();\n      let a_down = a_row.pop();\n      let b_up = b_row.shift();\n      a_row = [].concat(a_head, b_up, ...a_row);\n      b_row = [].concat(...b_row, a_down);\n    });\n    return rounds.reverse();\n  }\n\n  function bracketDrawPositions(draw) {\n    return [].concat(\n      ...draw.brackets.map((b, i) =>\n        d3\n          .range(draw.bracket_size)\n          .map((p, j) => ({ bracket: i, position: j + 1 }))\n      )\n    );\n  }\n\n  function rrInfo(draw) {\n    if (!draw.brackets) draw.brackets = [];\n    let draw_positions = bracketDrawPositions(draw);\n    let byes = draw.brackets.length * draw.bracket_size - draw.opponents.length;\n    let matches = [].concat(...draw.brackets.map((b) => b.matches));\n\n    let total = (a, b) => a + b;\n    let total_matches = draw.brackets\n      .map((b) => range(0, b.players.length).reduce(total, 0))\n      .reduce(total, 0);\n\n    let seed_placements = []\n      .concat(...draw.seed_placements.map((s) => s.placements))\n      .map((p) => p.position);\n    let unfinished_seed_placements = draw.seed_placements.filter(\n      (s) => s.range.length !== s.placements.length\n    );\n\n    let unseeded_placements = draw.unseeded_placements\n      ? draw.unseeded_placements.map((u) => u.position)\n      : [];\n    let placements = [].concat(\n      seed_placements,\n      draw.bye_placements || [],\n      unseeded_placements\n    );\n    let hashFx = (h) => [h.bracket, h.position].join(\"|\");\n    let p_hash = placements.map(hashFx);\n    let unfilled_positions = draw_positions.filter(\n      (p) => p_hash.indexOf(hashFx(p)) < 0\n    );\n    let completed_brackets = draw.brackets.map(bracketComplete);\n    let complete =\n      completed_brackets && completed_brackets.reduce((a, b) => a && b);\n    let positions_filled =\n      unseeded_placements &&\n      unseeded_placements.length &&\n      draw.unseeded_placements.length === draw.unseeded_teams.length;\n\n    let unplaced_seeds = [];\n    let open_seed_positions = [];\n    if (unfinished_seed_placements.length) {\n      let placed_seeds = unfinished_seed_placements[0].placements.map(\n        (p) => p.seed\n      );\n      unplaced_seeds = unfinished_seed_placements[0].range\n        .filter((s) => placed_seeds.indexOf(s) < 0)\n        .map((r) => draw.seeded_teams[r]);\n      let p_hash = unfinished_seed_placements[0].placements.map((p) =>\n        hashFx(p.position)\n      );\n      open_seed_positions = unfinished_seed_placements[0].positions.filter(\n        (p) => p_hash.indexOf(hashFx(p)) < 0\n      );\n    }\n\n    return {\n      draw_type: \"roundrobin\",\n      draw_positions,\n      matches,\n      positions_filled,\n      complete,\n      byes,\n      placements,\n      unfilled_positions,\n      total_matches,\n      unfinished_seed_placements,\n      unplaced_seeds,\n      open_seed_positions,\n    };\n  }\n\n  fx.compassInfo = compassInfo;\n  function compassInfo(draw) {\n    var complete,\n      total_matches = 0,\n      all_matches = [],\n      match_nodes = [],\n      upcoming_match_nodes = [],\n      unassigned = [];\n    let directions = [\n      \"east\",\n      \"west\",\n      \"north\",\n      \"south\",\n      \"northeast\",\n      \"northwest\",\n      \"southeast\",\n      \"southwest\",\n    ];\n    directions\n      .filter((d) => draw[d])\n      .forEach((direction) => {\n        let info = treeInfo(draw[direction]);\n        complete = complete || info.complete;\n        total_matches += info.total_matches;\n        all_matches = all_matches.concat(...info.all_matches);\n        match_nodes = match_nodes.concat(...info.match_nodes);\n        upcoming_match_nodes = upcoming_match_nodes.concat(\n          ...info.upcoming_match_nodes\n        );\n        unassigned = unassigned.concat(...info.unassigned);\n      });\n\n    return {\n      complete,\n      total_matches,\n      all_matches,\n      match_nodes,\n      upcoming_match_nodes,\n      unassigned,\n    };\n  }\n\n  fx.collapseHierarchy = collapseHierarchy;\n  function collapseHierarchy(node, depth) {\n    /*\n      if (node.depth <= depth) {\n         node._height = node.height;\n         node.height = node.height = node.height + 1 - depth;\n      }\n      */\n    if (node.depth >= depth) {\n      node._height = node.height;\n      node.height = node.height = 0;\n    }\n    if (node.depth === depth) {\n      node._children = node.children || node._children;\n      node.children = null;\n      return;\n    }\n    if (node.depth < depth) node.children = node.children || node._children;\n    if (!node.children) return;\n    node.children.forEach((c) => collapseHierarchy(c, depth));\n  }\n\n  fx.expandHierarchy = expandHierarchy;\n  function expandHierarchy(node) {\n    node.children = node.children || node._children;\n    node.height = node.height || node._height;\n    node._children = null;\n    node._height = null;\n    if (!node.children) return;\n    node.children.forEach((c) => expandHierarchy(c));\n  }\n\n  function treeInfo(draw, collapse) {\n    if (!draw) return {};\n    let calc_tree = d3.tree();\n    let draw_hierarchy = d3.hierarchy(draw);\n    let maxTreeDepth = draw.maxTreeDepth || collapse;\n    if (maxTreeDepth) collapseHierarchy(draw_hierarchy, maxTreeDepth);\n    let nodes = calc_tree(draw_hierarchy).descendants();\n\n    let depth = Math.max(...nodes.map((n) => n.depth));\n    let byes = nodes.filter((n) => !n.height && n.data.bye);\n    let structural_byes = nodes.filter(\n      (f) => +f.height === 0 && f.depth !== depth\n    );\n\n    let match_nodes = (nodes && nodes.filter((n) => matchNode(n))) || [];\n\n    let bye_nodes = match_nodes.filter((n) => !teamMatch(n, false));\n    let double_bye_nodes = match_nodes.filter((n) => byeNode(n) > 1);\n\n    let all_matches = nodes.filter(\n      (n) =>\n        n &&\n        n.children &&\n        n.children.length === 2 &&\n        (!draw.max_round || n.height <= draw.max_round)\n    );\n    var upcoming_match_nodes = all_matches.filter(\n      (n) => n && n.children && (qualifierChild(n) || !matchNode(n))\n    );\n    let doubles = nodes\n      .map((n) => (n.data.team ? n.data.team.length > 1 : false))\n      .reduce((a, b) => a || b);\n    let draw_positions = unique(nodes.map((n) => n.data.dp)).filter((f) => f);\n    let qualifiers = nodes.filter((n) => !n.height && n.data.qualifier);\n    let seeds = nodes\n      .filter(\n        (n) => !n.height && n.data.team && n.data.team[0] && n.data.team[0].seed\n      )\n      .sort((a, b) => a.data.team[0].seed - b.data.team[0].seed);\n    let final_round = draw.max_round\n      ? nodes.filter((f) => +f.height === +draw.max_round)\n      : nodes.filter((f) => +f.depth === 0);\n    let final_round_players = match_nodes\n      .filter((m) =>\n        draw.max_round ? +m.height === +draw.max_round : !m.depth\n      )\n      .map((m) => m.data.team);\n    let unassigned = nodes.filter(\n      (n) =>\n        !maxTreeDepth &&\n        !n.height &&\n        !n.data.team &&\n        !n.data.bye &&\n        !n.data.qualifier\n    );\n\n    let assignments = [].concat(\n      ...nodes\n        .filter(\n          (f) => !f.height && f.data.team && !f.data.qualifier && !f.data.bye\n        )\n        .map((node) => node.data.team.map((p) => ({ [p.id]: node.data.dp })))\n    );\n    let assigned_positions = assignments.length\n      ? Object.assign(...assignments)\n      : {};\n\n    let total_matches = all_matches.length - byes.length;\n    let complete =\n      match_nodes.length &&\n      match_nodes\n        .filter(validMatch)\n        .map((n) => byeChild(n) || (n.data.match && n.data.match.complete))\n        .reduce((p, c) => c && p, true);\n\n    function byeChild(n) {\n      return (\n        n &&\n        n.children &&\n        n.children.map((c) => c.data.bye).reduce((p, c) => c || p, false)\n      );\n    }\n    function qualifierChild(n) {\n      return (\n        n &&\n        n.children &&\n        !byeChild(n) &&\n        n.children.map((c) => c.data.qualifier).reduce((p, c) => c || p, false)\n      );\n    }\n    function validMatch(n) {\n      return !draw.max_round || n.height <= draw.max_round;\n    }\n\n    // function isStructuralBye(child) { return structural_byes.map(s=>s.data.dp).indexOf(child.data.dp) >= 0; }\n    // function upcomingChild(n) { return n.children && n.children.map(c=>ucmatch(c)).filter(f=>f).length === 2; }\n    // function ucmatch(c) { return matchNode(c) || ( isStructuralBye(c) && !c.data.children); }\n\n    return {\n      draw_type: \"tree\",\n      complete,\n      draw_positions,\n      assigned_positions,\n      seeds,\n      doubles,\n      nodes,\n      depth,\n      total_matches,\n      all_matches,\n      match_nodes,\n      upcoming_match_nodes,\n      byes,\n      bye_nodes,\n      double_bye_nodes,\n      structural_byes,\n      qualifiers,\n      final_round,\n      final_round_players,\n      unassigned,\n    };\n  }\n\n  fx.replaceDrawPlayer = replaceDrawPlayer;\n  function replaceDrawPlayer(draw, existing_player, new_player_data) {\n    if (\n      !draw ||\n      !existing_player ||\n      !new_player_data ||\n      typeof new_player_data !== \"object\"\n    )\n      return;\n    // Replace attributes in event.draw.opponents\n    if (draw.opponents)\n      draw.opponents.forEach((opponent_team) => {\n        opponent_team.forEach(checkReplacePlayer);\n      });\n    // Replace attributes in event.draw.seeded_teams\n    if (draw.seeded_teams)\n      Object.keys(draw.seeded_teams).forEach((key) =>\n        draw.seeded_teams[key].forEach(checkReplacePlayer)\n      );\n    // Replace attributes in event.draw.unseeded_teams\n    if (draw.unseeded_teams)\n      draw.unseeded_teams.forEach((opponent_team) => {\n        opponent_team.forEach(checkReplacePlayer);\n      });\n    // Replace attributes in event.draw.unseeded_placements\n    if (draw.unseeded_placements)\n      draw.unseeded_placements.forEach((placement) => {\n        if (placement.id === existing_player.id)\n          placement.id = new_player_data.id;\n      });\n    // Replace players in all draw matches\n    let matches = [];\n    if (draw.dual_matches) {\n      Object.keys(draw.dual_matches || {}).forEach((key) => {\n        let dual_matches = draw.dual_matches[key].matches || [];\n        dual_matches.forEach((dm) => (dm.dual_match = key));\n        matches = matches.concat(...dual_matches);\n      });\n    } else {\n      matches = fx.matches(draw).filter((m) => m.match && m.match.muid);\n    }\n    matches.forEach((match) => {\n      if (match.teams)\n        match.teams\n          .filter((f) => f)\n          .forEach((team) => team.forEach(checkReplacePlayer));\n      if (match.winner) match.winner.forEach(checkReplacePlayer);\n      if (match.loser) match.loser.forEach(checkReplacePlayer);\n      if (match.players) match.players.forEach(checkReplacePlayer);\n      if (match.ids) match.ids = match.players.map((p) => p.id);\n      if (match.match) {\n        if (match.match.teams)\n          match.match.teams.forEach((team) => team.forEach(checkReplacePlayer));\n        if (match.match.winner && Array.isArray(match.match.winner))\n          match.match.winner.forEach(checkReplacePlayer);\n        if (match.match.loser && Array.isArray * match.match.loser)\n          match.match.loser.forEach(checkReplacePlayer);\n        if (match.match.players)\n          match.match.players.forEach(checkReplacePlayer);\n        if (match.match.ids)\n          match.match.ids = match.match.players.map((p) => p.id);\n      }\n    });\n    if (draw.brackets) {\n      draw.brackets.forEach((bracket) =>\n        bracket.players.forEach(checkReplacePlayer)\n      );\n    }\n\n    function checkReplacePlayer(player) {\n      if (\n        player &&\n        (player.id === existing_player.id || player.id === existing_player.id)\n      ) {\n        Object.keys(new_player_data).forEach(\n          (key) => (player[key] = new_player_data[key])\n        );\n      }\n    }\n  }\n\n  fx.bracketComplete = bracketComplete;\n  function bracketComplete(bracket) {\n    return (\n      bracket.matches &&\n      bracket.matches.length &&\n      bracket.matches.filter((m) => m.winner).length === bracket.matches.length\n    );\n  }\n\n  fx.drawRounds = drawRounds;\n  function drawRounds(num_players) {\n    if (!num_players) return;\n    // get the binary representation of the number of players\n    let bin = d2b(num_players);\n    // result is length of binary string - 1 + 1 if there are any 1s after first digit\n    return bin.slice(1).length + (bin.slice(1).indexOf(1) >= 0 ? 1 : 0);\n    function d2b(dec) {\n      return (dec >>> 0).toString(2);\n    }\n  }\n\n  fx.calcFeedBase = ({ draw_positions }) => {\n    let positions = draw_positions && draw_positions.length;\n    if (!p2(positions)) {\n      positions += sByes(positions);\n    }\n    if (positions && p2(positions)) return positions / 2;\n  };\n\n  fx.feedDrawSize = feedDrawSize;\n  function feedDrawSize({ num_players, skip_rounds, feed_rounds }) {\n    let s = 0;\n    let burn = 0;\n    while (\n      calcFeedSize({\n        first_round_size: standard_draws[s],\n        skip_rounds,\n        feed_rounds,\n      }) < num_players &&\n      burn < 10\n    ) {\n      burn += 1;\n      s += 1;\n    }\n    if (burn >= 10) {\n      console.log(\"BOOM!\", num_players, skip_rounds, feed_rounds);\n      return standard_draws[1];\n    }\n    return standard_draws[s];\n  }\n\n  fx.calcFeedSize = calcFeedSize;\n  function calcFeedSize({ first_round_size, skip_rounds, feed_rounds }) {\n    if (!first_round_size) return 0;\n    let feed_capacity = first_round_size * 2 - 1;\n    let skip_reduce =\n      skip_rounds && skip_rounds > 0 ? first_round_size / (skip_rounds * 2) : 0;\n    let draw_rounds = drawRounds(first_round_size);\n    let possible_feed_rounds = draw_rounds - (skip_rounds || 0);\n    let feed_diff =\n      feed_rounds !== undefined ? possible_feed_rounds - feed_rounds : 0;\n    let feed_reduce =\n      feed_rounds !== undefined && feed_diff > 0\n        ? numArr(feed_diff)\n            .map((d) => Math.pow(2, d))\n            .reduce((a, b) => (a || 0) + (b || 0))\n        : 0;\n    return feed_capacity - skip_reduce - feed_reduce;\n  }\n\n  fx.drawInfo = drawInfo;\n  function drawInfo(draw, collapse) {\n    if (!draw) return;\n    if (draw.brackets) return rrInfo(draw);\n    if (draw.compass) {\n      let info = treeInfo(draw[draw.compass]);\n      if (info) info.compass = true;\n      return info;\n    }\n    if (draw.children) return treeInfo(draw, collapse);\n  }\n\n  fx.blankDraw = blankDraw;\n  function blankDraw(players, offset = 0) {\n    if (isNaN(players) || !validDrawSize(players)) return undefined;\n\n    // function dp(x) { return { dp: offset + x }; }\n    let dp = (x) => ({ dp: offset + x });\n    let positions = Array.from(new Array(players), (val, index) => index + 1);\n\n    return positions.map(dp);\n  }\n\n  fx.addByes = addByes;\n  function addByes(draw) {\n    let info = drawInfo(draw);\n    let draw_positions = info.draw_positions;\n    let max_draw_position = draw_positions.length\n      ? Math.max(...draw_positions)\n      : 0;\n    // let missing_draw_positions = max_draw_position ? Array.from(new Array(max_draw_position),(val,index)=>index+1).filter(p=>draw_positions.indexOf(p) < 0) : [];\n    /*\n      let chooseDrawPosition = (dp) => {\n         let np = missing_draw_positions.filter(p => Math.abs(dp - p) === 1)[0];\n         return np || '';\n      };\n      */\n\n    walkNode(draw);\n\n    function walkNode(node, descent = 0) {\n      if (descent < info.depth && !node.children) {\n        let position =\n          node.team && node.team[0].draw_position >= max_draw_position / 2\n            ? 0\n            : 1;\n        addBye(node, position);\n      }\n      if (node.children)\n        node.children.forEach((child) => walkNode(child, descent + 1));\n    }\n\n    function addBye(node, position = 1) {\n      let team = node.team;\n      let bye = { bye: true, team: [{ draw_position: \"\", bye: true }] };\n      let player = { dp: node.dp, id: node.id, team };\n      node.children = position ? [player, bye] : [bye, player];\n      node.match = { score: \"\" };\n    }\n  }\n\n  // return positions of structural byes\n  fx.structuralByes = structuralByes;\n  function structuralByes(players, bit_flip) {\n    let s = sByes(players);\n    let cluster_size = players / s;\n    let clusters = players / cluster_size;\n    let cluster = 1;\n    let bye_positions = [];\n    while (cluster <= clusters) {\n      let odd = cluster % 2;\n      if (bit_flip && cluster > 1 && cluster < clusters) odd = 1 - odd;\n      if (odd) {\n        bye_positions.push((cluster - 1) * cluster_size + 1);\n      } else {\n        bye_positions.push(cluster * cluster_size);\n      }\n      cluster += 1;\n    }\n    return bye_positions;\n  }\n\n  // number of structural byes\n  fx.sByes = sByes;\n  function sByes(players) {\n    if (p2(players)) return 0;\n    let b = 1;\n    while (b < players && !p2(players - b)) {\n      b += 1;\n    }\n    return b;\n  }\n\n  // check for power of 2\n  function p2(n) {\n    if (isNaN(n)) return false;\n    return n && (n & (n - 1)) === 0;\n  }\n\n  // WHAT WAS THIS?\n  fx.dispersion = dispersion;\n  function dispersion(num_players, depth) {\n    let values = [];\n    let p = num_players;\n    while (div2(p)) {\n      values.push(p);\n      p = p / 2;\n    }\n\n    let d = 0;\n    let positions = [];\n    values.forEach((value) => {\n      if (+d === +depth) {\n        positions.push(value);\n        positions.push(num_players - value + 1);\n      }\n      d += 1;\n    });\n    positions.sort((a, b) => a - b);\n    return positions;\n\n    function div2(n) {\n      if (isNaN(n)) return false;\n      return n / 2 === Math.floor(n / 2);\n    }\n  }\n\n  function buildRound({ e, tree, byes = [], fed, rounds }) {\n    let round = [];\n    let pos = 0;\n    while (pos < tree.length) {\n      if (byes.indexOf(pos + 1) >= 0) {\n        let node = tree[pos];\n        round.push(node);\n        pos += 1;\n      } else {\n        let child1 = tree[pos];\n        child1.fed = fed;\n        child1.round = rounds;\n        let child2 = tree[pos + 1];\n        if (child2) {\n          child2.fed = fed;\n          child2.round = rounds;\n        }\n\n        let node = { children: [child1, child2], nuid: UUID.new() };\n        round.push(node);\n        pos += 2;\n      }\n    }\n    return round;\n  }\n\n  fx.feedRound = feedRound;\n  function feedRound(draw, remaining, fed, rounds) {\n    let round = [];\n    let pos = 0;\n    while (pos < draw.length) {\n      let feed_arm = remaining.pop();\n      feed_arm.feed = true;\n      feed_arm.fed = fed + 1;\n      feed_arm.round = rounds;\n\n      let position = draw[pos];\n      position.round = rounds;\n      position.fed = fed + 1;\n\n      let match = { children: [position, feed_arm] };\n      round.push(match);\n      pos += 1;\n    }\n    return { round, remaining };\n  }\n\n  // TODO: Total Mess unless treeDraw() is configured properly\n  // which means (for now) options({ draw: { feed_in: true }});\n  /*\n   fx.doubleElimination = doubleElimination;\n   function doubleElimination(e, teams) {\n      let total_positions = Array.isArray(teams) ? teams.length : teams;\n      let main = buildDraw({ e, teams: total_positions });\n      let feed = feedInDraw({ e, teams: acceptedDrawSizes({ num_players: total_positions / 2 }), offset: total_positions });\n      let children = [main, feed];\n      return { children };\n   }\n   */\n\n  fx.feedInDraw = feedInDraw;\n  function feedInDraw({\n    e,\n    teams,\n    skip_rounds = 0,\n    /*sequentials=0, */ feed_rounds = 0,\n    offset,\n  }) {\n    let team_count = Array.isArray(teams) ? teams.length : teams;\n    if (team_count < 2) return;\n    let total_rounds = drawRounds(teams);\n    if (skip_rounds >= total_rounds) feed_rounds = 0;\n\n    let up2 = (x) => Math.pow(2, Math.ceil(Math.log(x) / Math.log(2)));\n    let players = up2(team_count + 1);\n    let positions = blankDraw(players, offset);\n\n    let remaining = positions.slice(positions.length / 2).reverse();\n    let round = buildRound({\n      e,\n      tree: positions.slice(0, positions.length / 2),\n    });\n\n    let rounds = 0;\n    while (round.length > 1 && skip_rounds > 0) {\n      round = buildRound({ e, tree: round });\n      skip_rounds -= 1;\n      rounds += 1;\n    }\n\n    // if (sequentials && sequentials > 1) feed_rounds = sequentials;\n\n    let fed = 0;\n    // let sequenced = 0;\n    if (round.length > 1 && fed < feed_rounds) {\n      ({ round, remaining } = feedRound(round, remaining, fed, rounds));\n      fed += 1;\n      // sequenced += 1;\n    }\n\n    /*\n      while(round.length > 1 && sequentials < sequenced) {\n         ({round, remaining} = feedRound(round, remaining, fed, rounds));\n         fed += 1;\n         sequenced += 1;\n      }\n      */\n\n    while (round.length > 1) {\n      round = buildRound({ e, tree: round, fed, rounds });\n      rounds += 1;\n      if (round.length > 1 && fed < feed_rounds) {\n        if (fed >= skip_rounds)\n          ({ round, remaining } = feedRound(round, remaining, fed, rounds));\n        fed += 1;\n      }\n    }\n\n    if (fed < feed_rounds) {\n      ({ round, remaining } = feedRound(round, remaining, fed, rounds));\n    }\n\n    return round && round.length ? round[0] : round;\n  }\n\n  fx.buildDraw = buildDraw;\n  function buildDraw({ e, teams, structural_byes, offset = 0, direction }) {\n    let round;\n    if (Array.isArray(teams)) {\n      round = teams.map((t, i) => ({ dp: offset + i + 1, team: t }));\n    } else {\n      if (isNaN(teams) || !validDrawSize(teams)) return undefined;\n      round = blankDraw(teams, offset);\n    }\n\n    structural_byes = structural_byes || structuralByes(round.length);\n\n    round = buildRound({ e, tree: round, byes: structural_byes });\n    while (round.length > 1) {\n      round = buildRound({ e, tree: round });\n    }\n    if (direction) round[0].direction = direction;\n    return round[0];\n  }\n\n  fx.buildQualDraw = buildQualDraw;\n  function buildQualDraw({ e, num_players, num_qualifiers }) {\n    let group_size = Math.ceil(num_players / num_qualifiers);\n    let section_size = standardDrawSize(group_size);\n    let sections = Array.from(new Array(num_qualifiers), (val, i) => i);\n    let children = sections.map((u, i) =>\n      buildDraw({ e, teams: section_size, offset: i * section_size })\n    );\n    let max_round = d3.hierarchy(children[0]).height;\n    return { children, max_round };\n  }\n\n  fx.assignPosition = assignPosition;\n  function assignPosition({\n    node,\n    position,\n    team = [{}],\n    bye,\n    qualifier,\n    propagate,\n    assigned,\n  }) {\n    if (!node || !position) return assigned;\n    if (+node.dp === +position) {\n      node.team = team;\n      node.team.forEach((player) => {\n        player.draw_position = position;\n        player.bye = bye;\n        player.qualifier = qualifier;\n        player.entry = player.entry ? player.entry : qualifier ? \"Q\" : \"\";\n      });\n      node.bye = bye;\n      node.qualifier = qualifier;\n      assigned = true;\n\n      if (!propagate) return assigned;\n    }\n    if (node.children) {\n      let result = node.children.map((child) =>\n        assignPosition({\n          node: child,\n          position,\n          team,\n          bye,\n          qualifier,\n          propagate,\n          assigned,\n        })\n      );\n      return result.reduce((a, b) => a || b);\n    }\n    return assigned;\n  }\n\n  fx.findPositionNode = findPositionNode;\n  function findPositionNode({ node, position }) {\n    if (+node.dp === +position) return node;\n    if (!node.children) return;\n\n    // if position in node children, get index;\n    let cdpi = node.children.map((c) => c.dp).indexOf(position);\n\n    if (cdpi >= 0) {\n      return node;\n    } else {\n      return []\n        .concat(\n          ...node.children.map((child) =>\n            findPositionNode({ node: child, position })\n          )\n        )\n        .filter((f) => f)[0];\n    }\n  }\n\n  fx.advancePosition = advancePosition;\n  function advancePosition({\n    draw,\n    position,\n    score,\n    set_scores,\n    matchFormat,\n    bye,\n    onlyIfBye,\n    winner,\n  }) {\n    let position_node = findPositionNode({ node: draw, position });\n\n    // don't advance if position_node already contains player\n    if (!position_node || position_node.dp) return;\n\n    return advanceToNode({\n      draw,\n      node: position_node,\n      position,\n      score,\n      set_scores,\n      matchFormat,\n      bye,\n      onlyIfBye,\n      winner,\n    });\n  }\n\n  fx.teamIsBye = (team) => team.map((p) => p.bye).reduce((a, b) => a && b);\n\n  function matchDrawPositions(match) {\n    return (\n      (match.players &&\n        match.players.reduce(\n          (p, c) =>\n            c && p.indexOf(c.draw_position) < 0 ? p.concat(c.draw_position) : p,\n          []\n        )) ||\n      []\n    );\n  }\n\n  fx.advanceToNode = advanceToNode;\n  function advanceToNode({\n    draw,\n    node,\n    position,\n    score,\n    set_scores,\n    complete,\n    matchFormat,\n    bye,\n    onlyIfBye,\n    winner,\n  }) {\n    // cannot advance if no position node\n    if (!node) return { advanced: false };\n    if (!node.match) node.match = {};\n\n    let current_match = node.match;\n    let round = current_match && current_match.round;\n    if (node.dp && round) {\n      let draw_matches = Array.isArray(draw.matches) && draw.matches;\n      let matches = draw_matches || fx.matches(draw) || [];\n      let match_draw_positions = matchDrawPositions(current_match);\n\n      let next_round_match = matches\n        .filter(\n          (m) =>\n            (m.round && m.round === round + 1) ||\n            (m.match && m.match.round && m.match.round === round + 1)\n        )\n        .reduce(\n          (p, m) =>\n            m.match &&\n            intersection(matchDrawPositions(m.match), match_draw_positions)\n              .length\n              ? m\n              : p,\n          undefined\n        );\n\n      let next_round_score =\n        next_round_match &&\n        next_round_match.match &&\n        next_round_match.match.score;\n      let next_round_draw_positions =\n        next_round_match && matchDrawPositions(next_round_match.match);\n\n      // if there is an existing position assigned to node AND if there is a subsequent match winner\n      // THEN: if the attempted assignment is not the same, fail\n      if (\n        next_round_score &&\n        next_round_draw_positions.indexOf(+position) < 0\n      ) {\n        return {\n          advanced: false,\n          error: \"Cannot change match outcome with subsequent match(es)\",\n        };\n      }\n      if (next_round_score && !complete) {\n        return {\n          advanced: false,\n          error:\n            \"Cannot enter an incomplete match score with subsequent matche(es)\",\n        };\n      }\n    }\n\n    // if position in node children, get index;\n    let cdpi = node.children.map((c) => c.dp).indexOf(position);\n    let teams = node.children.map((c) => c.team).filter((f) => f);\n    let containsByeTeam = teams.reduce((p, c) => fx.teamIsBye(c) || p, false);\n\n    if (teams.length === 2 && cdpi >= 0) {\n      if (onlyIfBye && !containsByeTeam) {\n        // condition don't advance the position *unless* there is a ByeTeam\n        return { advanced: false };\n      } else if (!bye && fx.teamIsBye(teams[cdpi])) {\n        return { advanced: false };\n      } else {\n        let opponent_is_bye = fx.teamIsBye(teams[1 - cdpi]);\n        advance(opponent_is_bye, bye);\n        return { advanced: true };\n      }\n    }\n\n    return { advanced: false };\n\n    function advance(opponent_is_bye, bye) {\n      node.children.forEach((child, i) => {\n        if (+child.dp === +position) {\n          node.bye = bye;\n          node.dp = position;\n          // draw position shouldn't really be assigned if not a winner\n          // but this needs to be thoroughly tested before changed...\n          // if (winner) node.dp = position;\n          node.team = child.team;\n          if (!opponent_is_bye) {\n            node.match.score = score;\n            node.match.winner_index = i;\n            node.match.winner = child.team;\n            node.match.set_scores = set_scores;\n            node.match.matchFormat = matchFormat;\n          }\n        } else {\n          if (!opponent_is_bye) node.match.loser = child.team;\n        }\n      });\n    }\n  }\n\n  /*\n   fx.findMatchNodeByPosition = findMatchNodeByPosition;\n   function findMatchNodeByPosition({ node, position }) {\n      let position_node = findPositionNode({ node, position });\n      if (!position_node) return;\n\n      let target_node;\n      if (+position_node.dp === +position) {\n         target_node = position_node;\n      } else {\n         // if position in node children, get index;\n         let cdpi = position_node.children.map(c => c.dp).indexOf(position);\n         target_node = position_node.children[cdpi];\n      }\n      if (!target_node.children) return;\n\n      let teams = target_node.children.map(c => c.team).filter(f=>f);\n      // let teamIsBye = (team) => team.map(p => p.bye).reduce((a, b) => a && b);\n      let byeTeam = teams.map(t => fx.teamIsBye(t)).reduce((a, b) => a && b);\n\n      if (teams.length === 2 && !byeTeam) return target_node;\n   }\n   */\n\n  fx.modifyPositionScore = modifyPositionScore;\n  function modifyPositionScore({\n    node,\n    positions,\n    score,\n    set_scores,\n    complete,\n    matchFormat,\n  }) {\n    let target_node = findMatchNodeByTeamPositions(node, positions);\n\n    if (!target_node) return;\n    if (!target_node.match) target_node.match = {};\n    target_node.match.score = score;\n    target_node.match.set_scores = set_scores;\n    target_node.match.matchFormat = matchFormat;\n    if (complete !== undefined) target_node.match.complete = complete;\n\n    // if match is incomplete remove any outdated attributes\n    if (!complete) {\n      delete target_node.team;\n      delete target_node.match.loser;\n      delete target_node.match.winner;\n      delete target_node.match.winner_index;\n    }\n  }\n\n  fx.schedulePosition = schedulePosition;\n  function schedulePosition({ node, position, schedule, venue }) {\n    let target_node = findPositionNode({ node, position });\n    if (!target_node.match) target_node.match = {};\n    target_node.match.schedule = schedule;\n    target_node.match.venue = venue;\n  }\n\n  fx.seedBlock = (seed) => {\n    let seed_block = o.seedBlocks.reduce(inSeedBlock, undefined);\n    return seed_block && seed_block.join(\"-\");\n    function inSeedBlock(p, c) {\n      if (c) {\n        let lower = c[0];\n        let higher = c[1] || c[0];\n        return seed >= lower && seed <= higher ? c : p;\n      }\n    }\n  };\n\n  fx.seedLimit = seedLimit;\n  function seedLimit({ total_players, evt }) {\n    let limit = 0;\n    // let event_seed_limit = evt && evt.seed_limit && (evt.seed_limit < total_players) && evt.seed_limit;\n    let event_seed_limit =\n      evt && evt.seeds && evt.seeds < total_players && evt.seeds;\n    if (event_seed_limit === 0) return 0;\n    o.seed_limits.forEach((threshold) => {\n      if (total_players >= threshold[0]) limit = threshold[1];\n    });\n    return event_seed_limit || limit;\n  }\n\n  fx.roundrobinSeedPlacements = roundrobinSeedPlacements;\n  function roundrobinSeedPlacements({ draw, bracket_size }) {\n    let placements = [];\n    let bracket_count = draw.brackets.length;\n    let seeded_team_keys = Object.keys(draw.seeded_teams);\n    let auto_placed_seeds = seeded_team_keys.slice(0, bracket_count);\n    let random_placed_seeds = seeded_team_keys.slice(bracket_count);\n\n    // Minimum one seed in first position for each bracket\n    d3.range(auto_placed_seeds.length).forEach((s) => {\n      // let bracket = draw.brackets[s % bracket_count];\n      placements.push({\n        range: [s + 1],\n        positions: [{ bracket: s % bracket_count, position: 1 }],\n        placements: [],\n      });\n    });\n\n    // final position of each bracket is available for other seeds to be placed randomly\n    let range = [];\n    let positions = [];\n    d3.range(bracket_count).forEach((s) => {\n      let seed_index = auto_placed_seeds.length + s;\n      // let bracket = draw.brackets[seed_index % bracket_count];\n\n      // the range is restricted by the number of remaining seeds\n      if (s < random_placed_seeds.length) range.push(seed_index + 1);\n      // but the positiosn are available in each bracket\n      positions.push({\n        bracket: seed_index % bracket_count,\n        position: bracket_size,\n      });\n    });\n\n    // randomize the order\n    d3.shuffle(positions);\n    placements.push({ range, positions, placements: [] });\n\n    return placements;\n  }\n\n  fx.qualifyingBracketSeeding = qualifyingBracketSeeding;\n  function qualifyingBracketSeeding({\n    draw,\n    num_players,\n    qualifiers /*, seed_limit*/,\n  }) {\n    let group_size = Math.ceil(num_players / qualifiers);\n    let section_size = standardDrawSize(group_size);\n    // let sections = Array.from(new Array(qualifiers),(val,i)=>i);\n\n    let placements = [];\n    let seeded_team_keys = Object.keys(draw.seeded_teams);\n\n    let auto_placed_seeds = seeded_team_keys.slice(0, qualifiers);\n    let random_placed_seeds = seeded_team_keys.slice(qualifiers);\n\n    // Minimum one seed in first position for each section\n    d3.range(auto_placed_seeds.length).forEach((s) => {\n      let position = (s % qualifiers) * section_size + 1;\n      placements.push({\n        range: [s + 1],\n        placements: [],\n        positions: [position],\n      });\n    });\n\n    let range = [];\n    let positions = [];\n\n    d3.range(random_placed_seeds.length).forEach((s) => {\n      let seed_index = auto_placed_seeds.length + s;\n      range.push(seed_index + 1);\n    });\n\n    // with some qualification draws there are more placement options than seeds to be placed\n    d3.range(auto_placed_seeds.length).forEach((s) => {\n      let position = (s % qualifiers) * section_size + section_size;\n      positions.push(position);\n    });\n\n    d3.shuffle(positions);\n    placements.push({ range, positions, placements: [] });\n\n    return placements;\n  }\n\n  fx.validSeedPlacements = validSeedPlacements;\n  function validSeedPlacements({\n    num_players,\n    random_sort = false,\n    seed_limit,\n    qualifying_draw,\n  }) {\n    let i = 1;\n    let placements = [];\n    let draw_size = acceptedDrawSizes({\n      num_players,\n      standardSizes: qualifying_draw,\n    });\n    seed_limit =\n      seed_limit || seedLimit({ total_players: num_players || draw_size });\n\n    while (i <= seed_limit) {\n      // array of possible placement positions\n      let p = seedPositions(o.seedPositions, i, draw_size);\n\n      // if sort then sort seed groupings\n      // if (random_sort) p = p.sort(() => 0.5 - Math.random());\n      if (random_sort) d3.shuffle(p);\n\n      placements.push({\n        range: playerPositions(i, p.length),\n        positions: p,\n        placements: [],\n      });\n      i += p.length || draw_size;\n    }\n    return placements;\n  }\n\n  // range of player positions\n  function playerPositions(s, n) {\n    return Array.from(new Array(n), (val, i) => i + s);\n  }\n  function seedPositions(seed_positions, i, draw_size) {\n    return seed_positions[i].map((d) => +d[0] + draw_size * d[1]);\n  }\n\n  /*\n      Byes drawn to the top half of the draw shall be positioned on even-numbered lines; byes drawn to the bottom half\n      of the draw shall be positioned on odd-numbered lines.\n\n      If group seeding is used and there are fewer byes available than there are players in the group, then a drawing\n      is used to determine which seeds within the group get the available byes. \n\n      TODO: Byes should have a bye-order attribute for this...\n      The Referee should note the order in which the remaining byes are placed in the draw in the event that this information is\n      needed later for placing an omitted player in the draw\n\n       First, distribute byes to all the seeds.\n       Second, distribute byes so that the seeded players who receive byes will be playing other players who have\n        also received byes. If there are not enough byes so that every seeded player is playing another player who has\n        received a bye, then position these byes adjacent to the seeded players starting with the lowest seeded player.\n       Third, distribute a pair of byes in the fourth quarter of\n        the draw starting from the bottom up; distribute a pair of byes in the first quarter of the draw starting from\n        the top down; distribute a pair of byes in the third quarter of the draw starting from the bottom up; distribute\n        a pair of byes in the second quarter of the draw starting from the top down; and repeat the cycle\n        (fourth quarter, first quarter, third quarter, and second quarter) until all the byes have been distributed.A\n   */\n\n  // distributeByes must occur after seed_positions have been determined\n  // EXCEPT for pre-rounds where all ranked players are seeded...\n  // seed_positions is an array of positions which has been sorted by seed #'s\n  // such that byes are handed out to seeds in order: 1, 2, 3...\n  fx.distributeByes = distributeByes;\n  function distributeByes({ draw, num_players, target_byes }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n\n    let info = drawInfo(current_draw);\n    let seed_positions = info.seeds.map((m) => m.data.dp);\n    let randomBinary = () => Math.floor(Math.random() * 2);\n\n    num_players =\n      num_players ||\n      (current_draw.opponents ? current_draw.opponents.length : 0) +\n        (current_draw.qualifiers || 0);\n\n    // bye_positions is an array of UNDEFINED with length = # of byes\n    // constructed by slicing from array number of actual teams/players\n    let bye_positions = info.draw_positions\n      .map(() => undefined)\n      .slice(num_players);\n\n    // all draw positions which have a first-round opponent (no structural bye);\n    let paired_positions = info.nodes\n      .filter((f) => +f.height === 1 && f.children)\n      .map((m) => [].concat(...m.children.map((c) => c.data.dp)));\n\n    // first round matches with no seeded position\n    let pairs_no_seed = paired_positions.filter(\n      (f) => intersection(seed_positions, f).length < 1\n    );\n\n    // first round matches with seeded position\n    let pairs_with_seed = paired_positions.filter(\n      (f) => intersection(seed_positions, f).length > 0\n    );\n\n    let draw_size = info.draw_positions.length;\n    let bp = (o.bye_placement && draw_size && o.bye_placement[draw_size]) || {};\n    let prescribed = target_byes || bp;\n\n    if (!info.structural_byes.length) {\n      // if there are not emough prescribed bye_positions then skip priscribed (!!)\n      if (prescribed && prescribed.length >= bye_positions.length) {\n        bye_positions = bye_positions.map((p, i) => prescribed[i]);\n      } else {\n        let seed_placements = current_draw.seed_placements\n          ? []\n              .concat(...current_draw.seed_placements.map((m) => m.placements))\n              .map((m) => m.position)\n          : [];\n\n        // if there are structural byes, then no seed should need bye\n        // if there are not structural byes, distribute byes to seeds first, by seed order\n        // First select pairs that match the seed_positions, which are already in order, with seed groups shuffled\n        // if there are more bye_positions than seed_positions, bye_positions remain undefined\n        let filtered_pairs = bye_positions.map(\n          (b, i) =>\n            pairs_with_seed.filter((p) => p.indexOf(seed_positions[i]) >= 0)[0]\n        );\n\n        bye_positions = []\n          .concat(...filtered_pairs)\n          .filter((f) => seed_placements.indexOf(f) < 0);\n      }\n    } else {\n      // find pairs of positions which are adjacent to structural byes\n      let adjacent_pairs = info.structural_byes\n        .map((sb) => sb.parent.children.filter((c) => c.data.children))\n        .map((m) => m[0].data.children.map((c) => c.dp));\n\n      let structural_seed_order = info.structural_byes.map((s) =>\n        s.data && s.data.team ? s.data.team[0].seed : undefined\n      );\n      let adjacent_to_seeds = [];\n      if (o.compressed.byes_adjacent_to_seeds) {\n        // only used this feature if enabled in drawFx options\n        structural_seed_order\n          .filter((f) => f)\n          .forEach((o, i) => (adjacent_to_seeds[o - 1] = adjacent_pairs[i]));\n      }\n      adjacent_to_seeds.filter((f) => f);\n\n      let assignment = bye_positions.map((b, i) =>\n        adjacent_to_seeds[i] ? adjacent_to_seeds[i][randomBinary()] : undefined\n      );\n\n      // keep track of pairs with no seed or bye\n      let pairs_no_seed_or_bye = pairs_no_seed.filter(\n        (pair) => !intersection(pair, assignment).length\n      );\n      let flat_pairs = [].concat(...pairs_no_seed_or_bye);\n\n      if (target_byes) {\n        // prescribed can't be fixed bye positions because these may create double-bye situations\n        bye_positions = bye_positions.map((p, i) => target_byes[i]);\n      } else {\n        // redefined undefined bye_positions to either be those asigned to adjacent pairs or pairs_no_seed_or_bye\n        bye_positions = assignment\n          .map((b) => {\n            if (b) return b;\n            // if (pairs_no_seed_or_bye.length) return randomPop(pairs_no_seed_or_bye)[Math.floor(Math.random() * 2)];\n            if (pairs_no_seed_or_bye.length)\n              return getBye(pairs_no_seed_or_bye);\n            return false;\n          })\n          .filter((f) => f);\n      }\n\n      // redefine pairs_no_seed to filter out pairs_no_seed_or_bye\n      pairs_no_seed = pairs_no_seed.filter(\n        (pair) => !intersection(pair, flat_pairs)\n      );\n    }\n\n    // if any bye positions are still undefined, randomly distribute to unseeded players\n    // TODO: randomPop need to be replaced with something that chooses quarters/eights\n    // let bye_placements = bye_positions.map(b => b || randomPop(pairs_no_seed)[Math.floor(Math.random() * 2)]);\n    let bye_placements = bye_positions.map((b) => b || getBye(pairs_no_seed));\n\n    bye_placements.forEach((position, i) => {\n      // bye is a boolean which also signifies bye order (order in which byes were assigned)\n      assignPosition({ node: current_draw, position, bye: i + 1 });\n    });\n\n    current_draw.bye_placements = bye_placements;\n    return bye_placements;\n\n    function getBye(source) {\n      let item = randomPop(source);\n      let rand = Math.floor(Math.random() * 2);\n      if (item) return item[rand];\n      console.log({ error: \"unable to pop\", source });\n    }\n  }\n\n  fx.rrByeDistribution = rrByeDistribution;\n  function rrByeDistribution({ draw }) {\n    let byes = draw.brackets.length * draw.bracket_size - draw.opponents.length;\n\n    if (byes > draw.brackets.length) {\n      // console.log('ERROR: There should never be more byes than brackets');\n      // Should only occur when too few players have been added to generate\n      return false;\n    }\n\n    draw.bye_placements = d3.range(byes).map((b, i) => {\n      draw.brackets[i].byes = [{ position: 2 }];\n      return { bracket: i, position: 2 };\n    });\n  }\n\n  function unplacedTeams(draw) {\n    /*\n      let seeds = (draw.seeded_teams && Object.keys(draw.seeded_teams)) || [];\n      let placed_seeds = [].concat(...(draw.seed_placements && draw.seed_placements.map(s=>s.placements.map(p=>p.seed))) || []);\n      let unplaced_seeds = seeds.map(s=>+s).filter(s => placed_seeds.indexOf(s) < 0);\n      let unplaced_seed_teams = draw.seeded_teams && unplaced_seeds.map(s=>draw.seeded_teams[s]);\n      */\n\n    let unseeded_placements = draw.unseeded_placements\n      ? [].concat(\n          ...draw.unseeded_placements.map((p) => p.team.map((m) => m.id))\n        )\n      : [];\n    let unplaced_unseeded = draw.unseeded_teams.filter(\n      (team) => unseeded_placements.indexOf(team[0].id) < 0\n    );\n\n    return unplaced_unseeded;\n  }\n\n  fx.rrUnseededPlacements = rrUnseededPlacements;\n  function rrUnseededPlacements({ draw }) {\n    if (o.separation.team) {\n      randomRRunseededSeparation({ draw });\n    } else {\n      randomRRunseededDistribution({ draw });\n    }\n  }\n\n  // Avoidance / Separation\n  function randomRRunseededSeparation({ draw }) {\n    let exit = false;\n    let unfilled_positions = fx.drawInfo(draw).unfilled_positions;\n    if (!draw.unseeded_placements) draw.unseeded_placements = [];\n\n    /**\n     * for each unfilled_position find the team of all other players in the\n     * bracket, then get array of all unplaced players who don't share the same team,\n     * then random pop from this group to make assignment...\n     * if there are no unplaced players with different team, then random pop from all unplaced players\n     */\n\n    while (unfilled_positions.length && !exit) {\n      let position = randomPop(unfilled_positions);\n\n      let teams = bracketTeams(draw.brackets[position.bracket]);\n      let unplaced_teams = unplacedTeams(draw);\n\n      let team_diff = unplaced_teams.filter(\n        (team) => teams.indexOf(team[0].team) < 0\n      );\n\n      if (o.separation.team && team_diff.length) {\n        let team = randomPop(team_diff);\n        placeTeam(team, position);\n      } else if (unplaced_teams.length) {\n        let team = randomPop(unplaced_teams);\n        placeTeam(team, position);\n      } else {\n        console.log(\"ERROR\");\n        exit = true;\n      }\n    }\n\n    function placeTeam(team, position) {\n      fx.pushBracketTeam({\n        draw,\n        team,\n        bracket_index: position.bracket,\n        position: position.position,\n      });\n      draw.unseeded_placements.push({ team, position });\n    }\n\n    function bracketTeams(bracket) {\n      if (!bracket || !bracket.players) return [];\n      return bracket.players.map((player) => player.team);\n    }\n  }\n\n  function randomRRunseededDistribution({ draw }) {\n    let unfilled_positions = fx.drawInfo(draw).unfilled_positions;\n\n    draw.unseeded_placements = draw.unseeded_teams.map((team) => {\n      let position = randomPop(unfilled_positions);\n\n      fx.pushBracketTeam({\n        draw,\n        team,\n        bracket_index: position.bracket,\n        position: position.position,\n      });\n\n      return { team, position };\n    });\n  }\n\n  fx.distributeQualifiers = distributeQualifiers;\n  function distributeQualifiers({ draw, num_qualifiers }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    let info = drawInfo(current_draw);\n    let total = info.draw_positions.length;\n    // let bye_positions = info.byes.map(b=>b.data.dp);\n    let unassigned_positions = info.unassigned.map((u) => u.data.dp);\n    let randomBinary = () => Math.floor(Math.random() * 2);\n    num_qualifiers = num_qualifiers || current_draw.qualifiers || 0;\n\n    // reverse qualifiers so that popping returns in numerical order\n    let qualifiers = d3\n      .range(0, num_qualifiers)\n      .map(() => {\n        return [{ entry: \"Q\", qualifier: true }];\n      })\n      .reverse();\n\n    let section_size = Math.floor(total / num_qualifiers);\n    let sections = d3.range(0, Math.floor(total / section_size));\n\n    // all draw positions which have a first-round opponent (no structural bye);\n    // let paired_positions = info.nodes.filter(f=>+f.height === 1 && f.children).map(m=>[].concat(...m.children.map(c=>c.data.dp)));\n\n    // paired positions which have no byes\n    // TODO: don't place qualifiers with BYEs unless there is no alternative\n    // let pairs_no_byes = paired_positions.filter(f=>intersection(bye_positions, f).length > 0);\n\n    d3.range(0, num_qualifiers).forEach(() => {\n      let section = randomPop(sections);\n      let dprange = d3.range(\n        section * section_size + 1,\n        section * section_size + section_size + 1\n      );\n      let available_positions = intersection(dprange, unassigned_positions);\n      let position = randomBinary()\n        ? available_positions.shift()\n        : available_positions.pop();\n      if (position) {\n        let team = qualifiers.pop();\n        assignPosition({ node: current_draw, position, team, qualifier: true });\n      }\n    });\n\n    qualifiers.forEach((team) => {\n      info = drawInfo(current_draw);\n      let available_positions = info.unassigned.map((u) => u.data.dp);\n      let position = available_positions.pop();\n      assignPosition({ node: current_draw, position, team, qualifier: true });\n    });\n  }\n\n  fx.seededTeams = seededTeams;\n  function seededTeams({ teams }) {\n    // this is an object that acts like an array... because there is no '0' seed\n    return Object.assign(\n      {},\n      ...teams\n        .filter((f) => f[0].seed)\n        .sort((a, b) => a[0].seed - b[0].seed)\n        .map((t) => ({ [t[0].seed]: t }))\n    );\n  }\n\n  fx.placeSeedGroups = placeSeedGroups;\n  function placeSeedGroups({ draw, count }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    if (!current_draw.seed_placements || !current_draw.seeded_teams) return;\n\n    // if no count is specified, place all seed groups\n    count = count || current_draw.seed_placements.length;\n    d3.range(0, count).forEach(() => placeSeedGroup({ draw: current_draw }));\n  }\n\n  fx.placeSeedGroup = placeSeedGroup;\n  function placeSeedGroup({ draw, group_index }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    if (!current_draw.seed_placements || !current_draw.seeded_teams) return;\n    let seed_group =\n      group_index !== undefined\n        ? current_draw.seed_placements[group_index]\n        : nextSeedGroup({ draw: current_draw });\n\n    if (!seed_group) return;\n\n    // make a copy so original is not diminshed by pop()\n    let positions = seed_group.positions.slice();\n\n    // pre-round draws place byes before remaining seeds... because all ranked players are seedeed\n    if (current_draw.bye_placements)\n      positions = positions.filter(\n        (p) => current_draw.bye_placements.indexOf(p) < 0\n      );\n\n    let missing_seeds = [];\n\n    seed_group.range.forEach((seed) => {\n      // positions should already be randomized\n      let position = positions.pop();\n      let team = current_draw.seeded_teams[seed];\n\n      if (!team) {\n        seed_group.positions = seed_group.positions.filter(\n          (p) => +p !== +position\n        );\n        missing_seeds.push(seed);\n        return;\n      }\n\n      if (current_draw.brackets) {\n        // procesing a round robin\n        fx.pushBracketTeam({\n          draw: current_draw,\n          team,\n          bracket_index: position.bracket,\n          position: position.position,\n        });\n      } else {\n        // processing a tree draw\n        assignPosition({ node: current_draw, position, team });\n      }\n      seed_group.placements.push({ seed, position });\n    });\n\n    if (missing_seeds.length) {\n      missing_seeds.forEach(\n        (s) => (seed_group.range = seed_group.range.filter((r) => r !== s))\n      );\n    }\n  }\n\n  fx.pushBracketTeam = ({ draw, team, bracket_index, position }) => {\n    let player = team[0];\n    player.draw_position = position;\n    draw.brackets[bracket_index].players.push(player);\n\n    team.forEach((opponent) => (opponent.draw_position = position));\n    draw.brackets[bracket_index].teams.push(team);\n  };\n\n  fx.nextSeedGroup = nextSeedGroup;\n  function nextSeedGroup({ draw }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    let unplaced = unplacedSeedGroups({ draw: current_draw });\n    return unplaced ? unplaced[0] : undefined;\n  }\n\n  fx.unplacedSeedGroups = unplacedSeedGroups;\n  function unplacedSeedGroups({ draw }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    if (\n      !current_draw.seed_placements ||\n      !Array.isArray(current_draw.seed_placements)\n    )\n      return;\n    return current_draw.seed_placements.filter(\n      (sp) => sp.range.length !== sp.placements.length\n    );\n  }\n\n  fx.roundMatches = ({ info, round }) => {\n    let all_matches = info && info.all_matches;\n    let round_matches =\n      (round !== undefined &&\n        all_matches &&\n        all_matches.filter((n) => n.height === round && !byeNode(n)).length) ||\n      0;\n    return round_matches;\n  };\n\n  fx.placeUnseededTeams = placeUnseededTeams;\n  function placeUnseededTeams({ draw }) {\n    let current_draw = draw.compass ? draw[draw.compass] : draw;\n    if (!current_draw.unseeded_teams) return;\n    if (o.separation.team && draw.opponents) {\n      randomUnseededSeparation({ draw: current_draw });\n    } else {\n      randomUnseededDistribution({ draw: current_draw });\n    }\n  }\n\n  function randomUnseededDistribution({ draw }) {\n    let unfilled_positions = drawInfo(draw).unassigned.map((u) => u.data.dp);\n    unfilled_positions.forEach((position) => {\n      let team = randomPop(draw.unseeded_teams);\n      if (team) assignPosition({ node: draw, position, team });\n    });\n  }\n\n  /*\n   After seeds have been placed...\n   For each iteration:\n   * 1) sort all teams by number of unplaced players and select team with most unplaced or randomly choose one of the teams which has the same/greatest number of unplaced members \n   * 2) randomly select a member of selected team\n   3) find the half/quarter/eighth or sixteenth with open positions and the fewest members of the same team\n   4) randomly place the selected member in one of the open positions in the selected fractional \n   Repeat\n   */\n\n  function findCandidate({ draw }) {\n    let info = fx.drawInfo(draw);\n\n    let draw_positions = info.draw_positions.sort(sortNumber);\n    let structural_bye_positions = info.structural_byes.map((b) => b.data.dp);\n    let draw_size = draw_positions.concat(...structural_bye_positions).length;\n    let unassigned_positions = info.unassigned\n      .map((u) => u.data.dp)\n      .sort(sortNumber);\n\n    let remaining = (unassigned_positions && unassigned_positions.length) || 0;\n    if (!remaining) return {};\n\n    let largestGroup = unpairedPositions(unassigned_positions);\n    let { opponent } = findOpponent({ largestGroup });\n    // console.log({opponent, largestGroup});\n\n    let opponent_teams = Object.assign(\n      {},\n      ...[].concat(...draw.opponents).map((o) => ({ [o.id]: o.team }))\n    );\n    let grouping_positions = Object.keys(info.assigned_positions).map(\n      groupingPosition\n    );\n    let opponent_groupings = opponent.map((o) => o.team);\n    let opponent_grouping_positions = grouping_positions\n      .filter((gp) => opponent_groupings.indexOf(gp.name) >= 0)\n      .map((gp) => gp.position);\n\n    let all_positions = range(1, draw_size + 1);\n    let chunk_sizes = range(2, draw_size)\n      .filter((f) => f === nearestPow2(f))\n      .reverse();\n    let chunks = chunk_sizes.map((size) => chunkArray(all_positions, size));\n    let vetted = chunks.map(chunkRow);\n\n    let group_not_present = vetted\n      .map((row) => row.filter((r) => !r.group_present))\n      .filter((f) => f);\n    let no_group_unpaired = group_not_present\n      .map((row) => row.filter((r) => r.unpaired.length).map((m) => m.unpaired))\n      .filter((f) => f && f.length);\n    let no_group_unassigned = group_not_present\n      .map((row) =>\n        row.filter((r) => r.unassigned.length).map((m) => m.unassigned)\n      )\n      .filter((f) => f && f.length);\n\n    let viable_sections =\n      (no_group_unpaired.length && no_group_unpaired[0]) ||\n      (no_group_unassigned.length && no_group_unassigned[0]);\n\n    let position;\n    if (viable_sections) {\n      let section = randomPop(viable_sections);\n      position = randomPop(section);\n    } else {\n      position = randomPop(unassigned_positions);\n    }\n\n    return { opponent, position, remaining };\n\n    function findOpponent({ largestGroup = true } = {}) {\n      let assigned = Object.keys(info.assigned_positions);\n      let unplaced_opponents = draw.opponents.filter(\n        (o) => assigned.indexOf(o[0].id) < 0\n      );\n\n      let groupings = {};\n      unplaced_opponents.forEach((team) => {\n        let grouping = teamGrouping(team);\n        groupings[grouping] = groupings[grouping]\n          ? groupings[grouping].concat([team])\n          : [team];\n      });\n      let max_length = Object.keys(groupings).reduce(\n        (p, c) => (groupings[c].length > p ? groupings[c].length : p),\n        0\n      );\n      let min_length = Object.keys(groupings).reduce(\n        (p, c) => (groupings[c].length < p ? groupings[c].length : p),\n        max_length\n      );\n\n      let groupings_meets_max = Object.keys(groupings).filter(\n        (f) => groupings[f].length === max_length\n      );\n      let groupings_meets_min = Object.keys(groupings).filter(\n        (f) => groupings[f].length === min_length\n      );\n\n      let random_group = largestGroup\n        ? randomPop(groupings_meets_max)\n        : randomPop(groupings_meets_min);\n      let random_opponent = randomPop(groupings[random_group]);\n\n      // console.log({ groupings, max_length, groupings_meets_max, random_group, random_opponent, unplaced_opponents });\n      return { opponent: random_opponent };\n\n      function teamGrouping(team) {\n        return team\n          .map((t) => t.team)\n          .sort()\n          .join(\"|\");\n      }\n    }\n\n    function unpairedPositions(positions) {\n      let true_positions = positions.map(truePosition);\n      return positions.filter((u) => !pairAssigned(u));\n\n      function pairAssigned(u) {\n        let true_position = truePosition(u);\n        let true_pair =\n          true_position % 2 ? true_position + 1 : true_position - 1;\n        return true_positions.indexOf(true_pair) < 0;\n      }\n    }\n\n    function checkChunk(chunk) {\n      let unassigned = unassigned_positions.filter(\n        (u) => chunk.indexOf(truePosition(u)) >= 0\n      );\n      let unpaired = unpairedPositions(unassigned);\n      let group_present = opponent_grouping_positions.reduce(\n        (p, g) => (chunk.indexOf(truePosition(g)) >= 0 ? true : p),\n        false\n      );\n      return { unassigned, unpaired, group_present };\n    }\n\n    function chunkArray(arr, chunksize) {\n      return arr.reduce((all, one, i) => {\n        const ch = Math.floor(i / chunksize);\n        all[ch] = [].concat(all[ch] || [], one);\n        return all;\n      }, []);\n    }\n    function sortNumber(a, b) {\n      return a - b;\n    }\n    function chunkRow(row) {\n      return row.map(checkChunk);\n    }\n    function truePosition(p) {\n      let isEven = (x) => !(x & 1);\n      let position = p + structural_bye_positions.filter((s) => s < p).length;\n      return structural_bye_positions.indexOf(p) >= 0 && isEven(p)\n        ? position + 1\n        : position;\n    }\n    function nearestPow2(val) {\n      return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));\n    }\n    function range(start, end) {\n      return Array.from({ length: end - start }, (v, k) => k + start);\n    }\n    function randomPop(array) {\n      return array.length\n        ? array.splice(Math.floor(Math.random() * array.length), 1)[0]\n        : undefined;\n    }\n    function groupingPosition(opponent_id) {\n      return {\n        name: opponent_teams[opponent_id],\n        position: info.assigned_positions[opponent_id],\n      };\n    }\n  }\n\n  // Avoidance / Separation\n  function randomUnseededSeparation({ draw }) {\n    let { opponent, position, remaining } = findCandidate({ draw });\n\n    for (let count = 0; count < remaining; count++) {\n      if (opponent) assignPosition({ node: draw, position, team: opponent });\n      ({ opponent, position } = findCandidate({ draw }));\n    }\n  }\n\n  fx.matchNodes = matchNodes;\n  function matchNodes(data) {\n    return drawInfo(data).match_nodes;\n  }\n\n  fx.matchNode = matchNode;\n  function matchNode(node) {\n    let teams = matchTeams(node);\n    return teams.length === 2 ? teams : false;\n  }\n\n  fx.matchTeams = matchTeams;\n  function matchTeams(node) {\n    if (!node || !node.data || !node.data.children) return false;\n    node.data.children.forEach((child) => {\n      if (\n        child &&\n        child.team &&\n        child.dp &&\n        child.team[0] &&\n        child.team[0].draw_position !== child.dp\n      ) {\n        child.team.forEach((team) => (team.draw_position = child.dp));\n      }\n    });\n    let teams = node.data.children.map((m) => m.team).filter((f) => f);\n    return teams;\n  }\n\n  fx.feedNode = feedNode;\n  function feedNode(node) {\n    if (!node || !node.data || !node.data.children) return false;\n    let feed_arms = node.data.children.map((m) => m.feed).filter((f) => f);\n    return feed_arms.length === 1 ? true : false;\n  }\n\n  fx.feedNodes = feedNodes;\n  function feedNodes(nodes) {\n    return nodes.filter(feedNode);\n  }\n\n  fx.byeTeams = byeTeams;\n  function byeTeams(node) {\n    if (!node.data.children) return false;\n    let teams = matchNode(node);\n    if (!teams) return false;\n    let test = node.data.children.map((d) => d.bye).filter((f) => f);\n    if (!test.length) return false;\n    return test.reduce((a, b) => a && b) ? teams : false;\n  }\n\n  fx.byeNode = byeNode;\n  function byeNode(node) {\n    if (!node.children) return false;\n    let test = node.data.children.map((d) => d.bye).filter((f) => f);\n    if (test.length) return test.length;\n  }\n\n  fx.teamMatch = teamMatch;\n  function teamMatch(node, includeQualifiers = true) {\n    if (!node.children) return false;\n    let teams = matchNode(node);\n    if (!teams) return false;\n    let test = node.data.children.map(isAteam).filter((f) => f);\n    if (test.length < 2) return false;\n    return test.reduce((a, b) => a && b) ? teams : false;\n\n    function isAteam(d) {\n      if (d.bye) return false;\n      if (d.qualifier && includeQualifiers) return false;\n      return true;\n    }\n  }\n\n  fx.drawPositionsWithBye = drawPositionsWithBye;\n  function drawPositionsWithBye(teams) {\n    return unique(\n      [].concat(\n        ...teams.map((node) =>\n          [].concat(\n            ...node.map((team) =>\n              team.map((player) =>\n                !player.bye ? player.draw_position : undefined\n              )\n            )\n          )\n        )\n      )\n    ).filter((f) => f);\n  }\n\n  fx.replaceEmptiesWithByes = replaceEmptiesWithByes;\n  function replaceEmptiesWithByes({ draw }) {\n    let info = drawInfo(draw);\n    let assigned_positions =\n      (info &&\n        Object.keys(info.assigned_positions).map(\n          (k) => info.assigned_positions[k]\n        )) ||\n      [];\n    let bye_positions = ((info && info.draw_positions) || []).filter(\n      (p) => assigned_positions.indexOf(p) < 0\n    );\n    bye_positions.forEach((position) => {\n      assignPosition({ node: draw, position, bye: true });\n    });\n  }\n\n  fx.advanceTeamsWithByes = advanceTeamsWithByes;\n  function advanceTeamsWithByes({ draw }) {\n    let info = drawInfo(draw);\n    // let winner_positions = (info && info.match_nodes && info.match_nodes.filter(n=>n.data.match && n.data.match.winner).map(n=>n.data.dp)) || [];\n    // let bye_teams = info.nodes.filter(f=>byeTeams(f)).map(m=>matchNode(m));\n    // let team_positions = drawPositionsWithBye(bye_teams).filter(p=>winner_positions.indexOf(p) < 0);\n    // team_positions.forEach(p => advancePosition({ draw, position: p, onlyIfBye: true }));\n\n    let match_nodes = info.match_nodes.filter((n) => !n.data.team);\n    let unadvanced = match_nodes.filter((m) =>\n      m.children.reduce((p, c) => c.data.bye || p, undefined)\n    );\n    let unadvanced_dp = [].concat(\n      ...unadvanced.map((u) => u.children.map((c) => c.data.dp))\n    );\n    let bye_dp = info.byes.map((b) => b.data.dp);\n    let unadvanced_player_dp = unadvanced_dp.filter(\n      (u) => bye_dp.indexOf(u) < 0\n    );\n    unadvanced_player_dp.forEach((p) =>\n      advancePosition({ draw, position: p, onlyIfBye: true })\n    );\n\n    if (info.bye_nodes)\n      info.bye_nodes.forEach((b) => {\n        if (b.data && b.data.match) {\n          delete b.data.match.schedule;\n        }\n      });\n    let unadvanced_double_byes = info.double_bye_nodes\n      .filter((n) => !hasBye(n))\n      .map((n) => n.data.children[0].dp);\n    unadvanced_double_byes.forEach((p) => {\n      advancePosition({ draw, position: p, bye: true, onlyIfBye: true });\n    });\n    if (unadvanced_double_byes.length) return advanceTeamsWithByes({ draw });\n  }\n\n  function hasBye(node) {\n    return (\n      node.data &&\n      node.data.team &&\n      node.data.team.reduce((p, c) => c.bye || p, undefined)\n    );\n  }\n\n  fx.findDualMatchNodeByMatch = (draw, muid) => {\n    let dual_match_muid = fx.findDualMatchMuid(draw, muid);\n    return fx.findDualMatchNode(draw, dual_match_muid);\n  };\n\n  fx.findDualMatchNode = (draw, dual_match_muid) => {\n    let info = draw && drawInfo(draw);\n    return (\n      info &&\n      info.match_nodes &&\n      info.match_nodes.reduce(\n        (p, c) =>\n          c.data.match && c.data.match.muid === dual_match_muid ? c : p,\n        undefined\n      )\n    );\n  };\n\n  fx.findDualMatchMuid = (draw, muid) => {\n    return (\n      draw.dual_matches &&\n      Object.keys(draw.dual_matches).reduce(\n        (p, c) =>\n          draw.dual_matches[c].matches.reduce(\n            (x, y) => (y.match.muid === muid ? y : x),\n            undefined\n          )\n            ? c\n            : p,\n        undefined\n      )\n    );\n  };\n\n  fx.findRRDualMatch = (draw, muid) => {\n    let dual_match_muid = fx.findDualMatchMuid(draw, muid);\n    let dual_matches = fx.matches(draw);\n    let dual_match = dual_matches.reduce(\n      (p, c) => (c.match.muid === dual_match_muid ? c : p),\n      undefined\n    );\n    return dual_match;\n  };\n\n  fx.findMatchNodeByTeamPositions = findMatchNodeByTeamPositions;\n  function findMatchNodeByTeamPositions(draw, positions) {\n    let info = drawInfo(draw);\n\n    let match_nodes = (info && info.match_nodes) || [];\n    let nodes = match_nodes\n      .filter((f) => fx.teamMatch(f))\n      .filter((match_node) => {\n        let match_positions = match_node.data.children.map((c) =>\n          c.team ? c.team[0].draw_position : undefined\n        );\n        return intersection(positions, match_positions).length === 2;\n      });\n    return nodes.length ? nodes[0].data : undefined;\n  }\n\n  fx.upcomingMatches = upcomingMatches;\n  function upcomingMatches(\n    data,\n    round_names = [],\n    calculated_round_names = []\n  ) {\n    if (!data) return [];\n    if (data.compass) return upcomingCompassMatches(data);\n\n    let info = drawInfo(data);\n    if (!info) return [];\n\n    if (info.draw_type === \"tree\") {\n      let round_offset = data.max_round ? info.depth - data.max_round : 0;\n      return treeMatches({\n        match_nodes: info.upcoming_match_nodes,\n        max_round: data.max_round,\n        round_offset,\n        round_names,\n        calculated_round_names,\n        potentials: true,\n      });\n    }\n\n    return [];\n  }\n\n  fx.treeMatches = treeMatches;\n  function treeMatches({\n    match_nodes,\n    max_round,\n    round_offset = 0,\n    round_names = [],\n    calculated_round_names = [],\n    potentials,\n    draw,\n  }) {\n    let matches = match_nodes\n      .filter((n) => potentials || teamMatch(n))\n      .filter((n) => (max_round ? n.height <= max_round : true))\n      .map((node) => {\n        let round_name = round_names.length\n          ? round_names[node.depth - round_offset]\n          : undefined;\n        if (round_name) node.data.round_name = round_name;\n\n        let calculated_round_name = calculated_round_names.length\n          ? calculated_round_names[node.depth - round_offset]\n          : undefined;\n        if (calculated_round_name)\n          node.data.calculated_round_name = calculated_round_name;\n\n        if (node.data.match && round_name)\n          node.data.match.round_name = round_name;\n        let potentials = node.data.children\n          .filter((c) => !c.team)\n          .map((p) => (p.children ? p.children.map((l) => l.team) : undefined));\n        let dependencies = node.data.children\n          .filter((c) => !c.team)\n          .map((d) => d.match && d.match.muid);\n        let dependent =\n          node.parent &&\n          node.parent.data &&\n          node.parent.data.match &&\n          node.parent.data.match.muid;\n        let this_match = {\n          dependent,\n          round_name,\n          potentials,\n          dependencies,\n          source: node,\n          round: node.height,\n          calculated_round_name,\n          match: node.data.match,\n          teams: node.data.children.map((c) => c.team).filter((f) => f),\n        };\n        if (draw) this_match.draw = draw;\n        return this_match;\n      });\n    return matches;\n  }\n\n  let compass_data = {\n    pre: {\n      east: \"E\",\n      west: \"W\",\n      north: \"N\",\n      south: \"S\",\n      northeast: \"NE\",\n      northwest: \"NW\",\n      southeast: \"SE\",\n      southwest: \"SW\",\n    },\n    names: [\"F\", \"SF\", \"QF\", \"R16\", \"R32\", \"R64\", \"R128\", \"R256\", \"R512\"],\n  };\n\n  function upcomingCompassMatches(data) {\n    let matches = []\n      .concat(\n        ...Object.keys(compass_data.pre)\n          .filter((key) => data[key])\n          .map((key) => {\n            let info = drawInfo(data[key]);\n            let max_round = data[key].max_round;\n            let round_offset = max_round ? info.depth - max_round : 0;\n            let round_names = compass_data.names.map(\n              (n) => `${compass_data.pre[key]}-${n}`\n            );\n            return treeMatches({\n              match_nodes: info.upcoming_match_nodes,\n              max_round,\n              round_offset,\n              round_names,\n              potentials: true,\n            });\n          })\n      )\n      .filter((m) => m && m.match);\n\n    return matches;\n  }\n\n  function compassMatches(data, all) {\n    let matches = [].concat(\n      ...Object.keys(compass_data.pre)\n        .filter((key) => data[key])\n        .map((key) => {\n          let info = drawInfo(data[key]);\n          let max_round = data[key].max_round;\n          let round_offset = max_round ? info.depth - max_round : 0;\n          let round_names = compass_data.names.map(\n            (n) => `${compass_data.pre[key]}-${n}`\n          );\n          let match_nodes = all ? info.all_matches : info.match_nodes;\n          return treeMatches({\n            match_nodes,\n            max_round,\n            round_offset,\n            round_names,\n            potentials: all,\n            draw: key,\n          });\n        })\n    );\n\n    return matches;\n  }\n\n  fx.extractDrawPlayers = (draw) => {\n    let players = [];\n    let draw_positions = [];\n    []\n      .concat(...fx.drawInfo(draw).nodes.map((n) => n.data && n.data.team))\n      .forEach((p) => {\n        if (draw_positions.indexOf(p.draw_position) < 0) {\n          draw_positions.push(p.draw_position);\n          players.push(p);\n        }\n      });\n    return players;\n  };\n\n  // will be replaced by drawMatches module\n  fx.matches = matches;\n  function matches(data, round_names = [], calculated_round_names = [], all) {\n    if (!data) return [];\n    if (data.compass) return compassMatches(data, all);\n\n    let info = drawInfo(data);\n    if (!info) return data.matches || [];\n\n    if (info.draw_type === \"tree\") {\n      let round_offset = data.max_round ? info.depth - data.max_round : 0;\n      let match_nodes = all ? info.all_matches : info.match_nodes;\n      return treeMatches({\n        match_nodes,\n        max_round: data.max_round,\n        round_offset,\n        round_names,\n        calculated_round_names,\n        potentials: all,\n      });\n    }\n\n    if (info.draw_type === \"roundrobin\") {\n      data.brackets.forEach((b, i) => bracketMatches(data, i));\n\n      let matches = []\n        .concat(...data.brackets.map((bracket) => bracket.matches))\n        .map((match) => {\n          return {\n            teams: match.teams || match.players.map((p) => [p]),\n            round_name: match.round_name,\n            result_order: match.result_order,\n            match,\n          };\n        });\n      return matches;\n    }\n\n    return [];\n  }\n\n  fx.tallyBracketAndModifyPlayers = ({\n    matches,\n    teams,\n    per_player,\n    reset,\n    qualifying,\n    matchFormat,\n  }) => {\n    if (!matches || !matches.length) return;\n\n    per_player = per_player || (teams && teams.length - 1) || 1;\n    let tbr = tallyBracket({ matches, per_player, qualifying, matchFormat });\n\n    let instanceCount = (values) =>\n      values.reduce((a, c) => {\n        // eslint-disable-next-line\n        a[c]++ ? 0 : (a[c] = 1);\n        return a;\n      }, {});\n    let qordz = Object.keys(tbr.team_results).map(\n      (t) => tbr.team_results[t].qorder\n    );\n    let ic = instanceCount(qordz);\n\n    let valid_for_suborder = Object.keys(ic).reduce(\n      (p, c) => (ic[c] > 1 ? p.concat(parseInt(c)) : p),\n      []\n    );\n    matches.forEach(\n      (match) => (match.results_order = tbr.match_result_order[match.muid])\n    );\n\n    teams.forEach((team) => {\n      let phash = playersHash(team);\n      if (tbr.team_results[phash]) {\n        team.forEach((player) => {\n          player.qorder = tbr.team_results[phash].qorder;\n\n          if (reset) {\n            // in this case sub_order is overridden\n            player.sub_order = tbr.team_results[phash].sub_order;\n          } else {\n            // in this context sub_order give preference to existing value\n            player.sub_order =\n              (valid_for_suborder.indexOf(player.qorder) >= 0 &&\n                player.sub_order) ||\n              tbr.team_results[phash].sub_order;\n          }\n\n          player.points_order = tbr.team_results[phash].points_order;\n          player.results = {\n            matches_won: tbr.team_results[phash].matches_won,\n            matches_lost: tbr.team_results[phash].matches_lost,\n            sets_won: tbr.team_results[phash].sets_won,\n            sets_lost: tbr.team_results[phash].sets_lost,\n            games_won: tbr.team_results[phash].games_won,\n            games_lost: tbr.team_results[phash].games_lost,\n            points_won: tbr.team_results[phash].points_won,\n            points_lost: tbr.team_results[phash].points_lost,\n\n            matches_ratio: tbr.team_results[phash].matches_ratio,\n            sets_ratio: tbr.team_results[phash].sets_ratio,\n            games_ratio: tbr.team_results[phash].games_ratio,\n            points_ratio: tbr.team_results[phash].points_ratio,\n\n            ratio_hash: tbr.team_results[phash].ratio_hash,\n          };\n          player.result = tbr.team_results[phash].result;\n          player.games = tbr.team_results[phash].games;\n        });\n      }\n    });\n\n    return true;\n  };\n\n  fx.tallyBracket = tallyBracket;\n  function tallyBracket({ matches, per_player, qualifying, matchFormat }) {\n    let bracket_match_format = matchFormatCode.parse(matchFormat) || {};\n    // if bracket is incomplete don't use expected matches per_player for calculating\n    let bracket_complete =\n      matches &&\n      matches.length &&\n      matches.filter((m) => m.winner).length === matches.length;\n    if (!bracket_complete) per_player = 0;\n\n    let disqualified = [];\n    let team_results = {};\n    let match_result_order = {};\n    let h2h = o.rr_h2h_priority;\n\n    if (!matches) return;\n\n    // for all matches winner score comes first!\n    matches\n      .filter((f) => f)\n      .forEach((match) => {\n        let match_format =\n          matchFormatCode.parse(match.matchFormat || matchFormat) || {};\n        if (match.winner && match.loser) {\n          let wH = getIdentifier(match.winner);\n          let lH = getIdentifier(match.loser);\n\n          if (!wH || !lH) {\n            // if there is an undefined winner/loser then the match was cancelled\n            let team1 =\n              match.teams && match.teams[0] && getIdentifier(match.teams[0]);\n            let team2 =\n              match.teams && match.teams[1] && getIdentifier(match.teams[1]);\n            if (team1) {\n              checkTeam(team1);\n              team_results[team1].matches_cancelled += 1;\n            }\n            if (team2) {\n              checkTeam(team2);\n              team_results[team2].matches_cancelled += 1;\n            }\n            return;\n          }\n\n          checkTeam(wH);\n          checkTeam(lH);\n          if (match.score && disqualifyingScore(match.score))\n            disqualified.push(lH);\n\n          team_results[wH].matches_won += 1;\n          team_results[lH].matches_lost += 1;\n          team_results[lH].defeats.push(wH);\n          team_results[wH].victories.push(lH);\n\n          let sets_tally = countSets(match.score, 0, match_format);\n          team_results[wH].sets_won += sets_tally[0];\n          team_results[wH].sets_lost += sets_tally[1];\n          team_results[lH].sets_won += sets_tally[1];\n          team_results[lH].sets_lost += sets_tally[0];\n\n          let games_tally = countGames(match.score, 0, match_format);\n          team_results[wH].games_won += games_tally[0];\n          team_results[wH].games_lost += games_tally[1];\n          team_results[lH].games_won += games_tally[1];\n          team_results[lH].games_lost += games_tally[0];\n\n          let points_tally = countPoints(match.score);\n          team_results[wH].points_won += points_tally[0];\n          team_results[wH].points_lost += points_tally[1];\n          team_results[lH].points_won += points_tally[1];\n          team_results[lH].points_lost += points_tally[0];\n        } else {\n          if (match.teams)\n            match.teams.forEach((team) => checkTeam(getIdentifier(team)));\n        }\n      });\n\n    function getIdentifier(opponent) {\n      if (!Array.isArray(opponent) && opponent.players && opponent.id) {\n        return opponent.id;\n      }\n      return playersHash(opponent);\n    }\n\n    function checkTeam(phash) {\n      if (!team_results[phash])\n        team_results[phash] = {\n          matches_won: 0,\n          matches_lost: 0,\n          victories: [],\n          defeats: [],\n          matches_cancelled: 0,\n          sets_won: 0,\n          sets_lost: 0,\n          games_won: 0,\n          games_lost: 0,\n          points_won: 0,\n          points_lost: 0,\n        };\n    }\n\n    // the difference here is totlas must be calcuulated using the expected\n    // match scoring format for the bracket, not the inidivudal match formats\n    let bracket_sets_to_win = scoreFx.setsToWin(bracket_match_format.bestOf);\n    let bracket_games_for_set =\n      bracket_match_format.setFormat && bracket_match_format.setFormat.setTo;\n\n    Object.keys(team_results).forEach((phash) => {\n      let sets_numerator = team_results[phash].sets_won;\n      let sets_denominator = team_results[phash].sets_lost;\n      let sets_total =\n        per_player * (bracket_sets_to_win || 0) || sets_numerator;\n      let sets_ratio =\n        Math.round((sets_numerator / sets_denominator) * 1000) / 1000;\n      if (sets_ratio === Infinity || isNaN(sets_ratio)) sets_ratio = sets_total;\n\n      let matches_numerator = team_results[phash].matches_won;\n      let matches_denominator = team_results[phash].matches_lost;\n      let matches_ratio =\n        Math.round((matches_numerator / matches_denominator) * 1000) / 1000;\n      if (matches_ratio === Infinity || isNaN(matches_ratio))\n        matches_ratio = matches_numerator;\n\n      let games_numerator = team_results[phash].games_won;\n      let games_denominator = team_results[phash].games_lost;\n      let games_total =\n        per_player *\n          (bracket_sets_to_win || 0) *\n          (bracket_games_for_set || 0) || games_numerator;\n      let games_ratio =\n        Math.round((games_numerator / games_denominator) * 1000) / 1000;\n      if (games_ratio === Infinity || isNaN(games_ratio)) {\n        games_ratio = games_total;\n      }\n      let games_difference =\n        games_denominator >= games_numerator\n          ? 0\n          : games_numerator - games_denominator;\n\n      let points_ratio =\n        Math.round(\n          (team_results[phash].points_won / team_results[phash].points_lost) *\n            1000\n        ) / 1000;\n      if (points_ratio === Infinity || isNaN(points_ratio)) points_ratio = 0;\n\n      team_results[phash].sets_ratio = sets_ratio;\n      team_results[phash].matches_ratio = matches_ratio;\n      team_results[phash].games_ratio = games_ratio;\n      team_results[phash].games_difference = games_difference;\n      team_results[phash].points_ratio = points_ratio;\n      team_results[\n        phash\n      ].result = `${team_results[phash].matches_won}/${team_results[phash].matches_lost}`;\n      team_results[\n        phash\n      ].games = `${team_results[phash].games_won}/${team_results[phash].games_lost}`;\n    });\n\n    let order = determineTeamOrder(team_results);\n\n    if (order) {\n      let ro_list = order.map((o) => o.rank_order);\n\n      order.forEach((o) => {\n        team_results[o.id].ratio_hash = o.ratio_hash;\n        if (o !== undefined && o.rank_order !== undefined) {\n          team_results[o.id].qorder = o.rank_order;\n          if (\n            occurrences(o.rank_order, ro_list) > 1 &&\n            team_results[o.id].sub_order === undefined\n          ) {\n            team_results[o.id].sub_order = 0;\n          } else if (occurrences(o.rank_order, ro_list) === 1) {\n            team_results[o.id].sub_order = undefined;\n          }\n        }\n\n        // calculate order for awarding points\n        if (o !== undefined && o.points_order !== undefined) {\n          team_results[o.id].points_order = o.points_order;\n        } else {\n          team_results[o.id].points_order = undefined;\n        }\n      });\n    }\n\n    // create an object mapping id to order\n    let id_order = Object.keys(team_results).reduce((o, t) => {\n      o[t] = team_results[t].points_order;\n      return o;\n    }, {});\n\n    matches.forEach((match) => {\n      let order =\n        match.winner_index === undefined\n          ? \"\"\n          : id_order[getIdentifier(match.winner)];\n      match_result_order[match.muid] = `RR${qualifying ? \"Q\" : \"\"}${\n        order || \"\"\n      }`;\n    });\n\n    return { team_results, match_result_order };\n\n    function walkedOver(score) {\n      return /W/.test(score) && /O/.test(score);\n    }\n    function defaulted(score) {\n      return /DEF/.test(score);\n    }\n    function retired(score) {\n      return /RET/.test(score);\n    }\n    function disqualifyingScore(score) {\n      return walkedOver(score) || defaulted(score);\n    }\n\n    function countSets(score, winner, match_format) {\n      let sets_to_win = scoreFx.setsToWin(match_format.bestOf);\n\n      let sets_tally = [0, 0];\n      if (!score) return sets_tally;\n      if (disqualifyingScore(score)) {\n        if (winner !== undefined && sets_to_win)\n          sets_tally[winner] = sets_to_win;\n      } else {\n        let set_scores = score.split(\" \");\n        set_scores.forEach((set_score) => {\n          let divider =\n            set_score.indexOf(\"-\") > 0\n              ? \"-\"\n              : set_score.indexOf(\"/\") > 0\n              ? \"/\"\n              : undefined;\n          let scores =\n            // eslint-disable-next-line no-useless-escape\n            /\\d+[\\(\\)\\-\\/]*/.test(set_score) && divider\n              ? set_score.split(divider).map((s) => /\\d+/.exec(s)[0])\n              : undefined;\n          if (scores) {\n            sets_tally[parseInt(scores[0]) > parseInt(scores[1]) ? 0 : 1] += 1;\n          }\n        });\n      }\n      if (retired(score) && winner !== undefined && sets_to_win) {\n        // if the loser has sets_to_win then last set was incomplete and needs to be subtracted from loser\n        if (+sets_tally[1 - winner] === sets_to_win)\n          sets_tally[1 - winner] -= 1;\n        sets_tally[winner] = sets_to_win;\n      }\n      return sets_tally;\n    }\n\n    function countPoints(score) {\n      let points_tally = [0, 0];\n      if (!score) return points_tally;\n      let set_scores = score.split(\" \");\n      set_scores.forEach((set_score) => {\n        let scores = /\\d+\\/\\d+/.test(set_score)\n          ? set_score.split(\"/\").map((s) => /\\d+/.exec(s)[0])\n          : [0, 0];\n        if (scores) {\n          points_tally[0] += parseInt(scores[0]);\n          points_tally[1] += parseInt(scores[1]);\n        }\n      });\n      return points_tally;\n    }\n\n    function countGames(score, winner, match_format) {\n      let sets_to_win = scoreFx.setsToWin(match_format.bestOf);\n      let games_for_set =\n        match_format.setFormat && match_format.setFormat.setTo;\n      let tiebreaks_at =\n        match_format.setFormat && match_format.setFormat.tiebreakAt;\n      if (!score) return [0, 0];\n      let min_winning_games = sets_to_win * games_for_set;\n      let games_tally = [[], []];\n      if (disqualifyingScore(score)) {\n        if (winner !== undefined && sets_to_win && games_for_set) {\n          games_tally[winner].push(min_winning_games);\n        }\n      } else {\n        let set_scores = score.split(\" \");\n        set_scores.forEach((set_score) => {\n          let scores =\n            // eslint-disable-next-line no-useless-escape\n            /\\d+[\\(\\)\\-\\/]*/.test(set_score) && set_score.indexOf(\"-\") > 0\n              ? set_score.split(\"-\").map((s) => /\\d+/.exec(s)[0])\n              : undefined;\n          if (scores) {\n            games_tally[0].push(parseInt(scores[0]));\n            games_tally[1].push(parseInt(scores[1]));\n          }\n        });\n      }\n      if (\n        retired(score) &&\n        winner !== undefined &&\n        sets_to_win &&\n        games_for_set\n      ) {\n        let sets_tally = countSets(score, winner, match_format);\n        let total_sets = sets_tally.reduce((a, b) => a + b, 0);\n        let loser_lead_set = games_tally\n          .map((g) => g[winner] <= g[1 - winner])\n          .reduce((a, b) => a + b, 0);\n        // if sets where loser lead > awarded sets, adjust last game to winner\n        if (loser_lead_set > sets_tally[1 - winner]) {\n          let tallied_games = games_tally[winner].length;\n          let complement = getComplement(\n            games_tally[1 - winner][tallied_games - 1]\n          );\n          if (complement) games_tally[winner][tallied_games - 1] = complement;\n        }\n        // if the total # of sets is less than games_tally[x].length award games_for_set to winner\n        if (total_sets > games_tally[winner].length) {\n          games_tally[winner].push(games_for_set);\n        }\n      }\n      let result = [\n        games_tally[0].reduce((a, b) => a + b, 0),\n        games_tally[1].reduce((a, b) => a + b, 0),\n      ];\n      if (winner !== undefined && result[winner] < min_winning_games)\n        result[winner] = min_winning_games;\n      return result;\n\n      function getComplement(value) {\n        if (!match_format || value === \"\") return;\n        if (+value === tiebreaks_at - 1 || +value === tiebreaks_at)\n          return parseInt(tiebreaks_at || 0) + 1;\n        if (+value < tiebreaks_at) return games_for_set;\n        return tiebreaks_at;\n      }\n    }\n\n    function determineTeamOrder(team_results) {\n      let team_ids = Object.keys(team_results);\n      let total_opponents = team_ids.length;\n\n      // order is an array of objects formatted for processing by ties()\n      let order = team_ids.reduce((arr, team_id, i) => {\n        arr.push({ id: team_id, i, results: team_results[team_id] });\n        return arr;\n      }, []);\n      let complete = order.filter(\n        (o) =>\n          total_opponents - 1 ===\n          o.results.matches_won +\n            o.results.matches_lost +\n            o.results.matches_cancelled\n      );\n\n      // if not all opponents have completed their matches, no orders are assigned\n      if (total_opponents !== complete.length) {\n        return;\n      }\n\n      complete.forEach((p) => (p.order_hash = orderHash(p)));\n      complete.forEach((p) => (p.ratio_hash = ratioHash(p)));\n\n      // START ORDER HASH\n      if (h2h) {\n        complete.sort(\n          (a, b) => (b.results.matches_won || 0) - (a.results.matches_won || 0)\n        );\n        let wins = complete.map((p) => p.results.matches_won);\n        let counts = unique(wins);\n        counts.forEach((count) => {\n          let i = indices(count, wins);\n          if (i.length && i.length > 1) {\n            let start = Math.min(...i);\n            let end = Math.max(...i);\n            let n = end - start + 1;\n            if (n === 2) {\n              complete = subSort(complete, start, n, h2hOrder);\n            } else {\n              complete = subSort(complete, start, n, orderHashSort);\n            }\n          }\n        });\n      } else {\n        complete.sort(orderHashSort);\n      }\n\n      let hash_order = unique(complete.map((c) => c.order_hash));\n      complete.forEach(\n        (p) => (p.hash_order = hash_order.indexOf(p.order_hash) + 1)\n      );\n\n      // now account for equivalent hash_order\n      let rank_order = 0;\n      let rank_hash = undefined;\n      complete.forEach((p, i) => {\n        if (p.order_hash !== rank_hash) {\n          rank_order = i + 1;\n          rank_hash = p.order_hash;\n        }\n        p.rank_order = rank_order;\n      });\n      // END ORDER HASH\n\n      // START RATIO HASH\n      if (h2h) {\n        complete.sort(\n          (a, b) => (b.results.matches_won || 0) - (a.results.matches_won || 0)\n        );\n        let wins = complete.map((p) => p.results.matches_won);\n        let counts = unique(wins);\n        counts.forEach((count) => {\n          let i = indices(count, wins);\n          if (i.length && i.length > 1) {\n            let start = Math.min(...i);\n            let end = Math.max(...i);\n            let n = end - start + 1;\n            if (n === 2) {\n              complete = subSort(complete, start, n, h2hRatio);\n            } else {\n              complete = subSort(complete, start, n, ratioHashSort);\n            }\n          }\n        });\n      } else {\n        complete.sort(ratioHashSort);\n      }\n\n      let ratio_order = unique(complete.map((c) => c.ratio_hash));\n      complete.forEach(\n        (p) => (p.ratio_order = ratio_order.indexOf(p.ratio_hash) + 1)\n      );\n\n      // points_order is used for awarding points and may differ from\n      // rank_order if a player unable to advance due to walkover\n      let points_order = 0;\n      let ratio_hash = undefined;\n      complete.forEach((p, i) => {\n        if (p.ratio_hash !== ratio_hash) {\n          points_order = i + 1;\n          ratio_hash = p.ratio_hash;\n        }\n        p.points_order = points_order;\n      });\n      // END RATIO HASH\n\n      return complete;\n\n      function ratioHashSort(a, b) {\n        return b.ratio_hash - a.ratio_hash;\n      }\n      function orderHashSort(a, b) {\n        return b.order_hash - a.order_hash;\n      }\n      function h2hRatio(a, b) {\n        let h2h_a = a.results.victories.indexOf(b.id) >= 0;\n        let h2h_b = b.results.victories.indexOf(a.id) >= 0;\n        if (h2h_a || h2h_b) {\n          return h2h_b ? 1 : -1;\n        }\n        return b.ratio_hash - a.ratio_hash;\n      }\n\n      function h2hOrder(a, b) {\n        let h2h_a = a.results.victories.indexOf(b.id) >= 0;\n        let h2h_b = b.results.victories.indexOf(a.id) >= 0;\n        if (h2h_a || h2h_b) {\n          return h2h_b ? 1 : -1;\n        }\n        return b.order_hash - a.order_hash;\n      }\n\n      function orderHash(p) {\n        if (disqualified.indexOf(p.id) >= 0) return 0;\n        return ratioHash(p);\n      }\n      function ratioHash(p) {\n        let rh;\n        if (h2h) {\n          rh =\n            p.results.matches_ratio * Math.pow(10, 16) +\n            p.results.sets_ratio * Math.pow(10, 12) +\n            p.results.games_difference * Math.pow(10, 8) +\n            p.results.points_ratio * Math.pow(10, 3);\n        } else {\n          rh =\n            p.results.matches_ratio * Math.pow(10, 16) +\n            p.results.sets_ratio * Math.pow(10, 12) +\n            p.results.games_ratio * Math.pow(10, 8) +\n            p.results.points_ratio * Math.pow(10, 3);\n        }\n        return rh;\n      }\n    }\n  }\n\n  function keyWalk(valuesObject, optionsObject) {\n    if (!valuesObject || !optionsObject) return;\n    var vKeys = Object.keys(valuesObject);\n    var oKeys = Object.keys(optionsObject);\n    for (var k = 0; k < vKeys.length; k++) {\n      if (oKeys.indexOf(vKeys[k]) >= 0) {\n        var oo = optionsObject[vKeys[k]];\n        var vo = valuesObject[vKeys[k]];\n        if (\n          oo &&\n          typeof oo === \"object\" &&\n          typeof vo !== \"function\" &&\n          oo.constructor !== Array\n        ) {\n          keyWalk(valuesObject[vKeys[k]], optionsObject[vKeys[k]]);\n        } else {\n          optionsObject[vKeys[k]] = valuesObject[vKeys[k]];\n        }\n      }\n    }\n  }\n\n  return fx;\n}\n","import { typeCheck as tc } from \"./typeCheck\";\nimport { courtData, ctuuid } from \"./courtFx\";\nimport { scoreFx } from \"./scoreFx\";\nimport { dateFx } from \"./dateFx\";\nimport { drawFx } from \"./drawFx\";\nimport { UUID } from \"./UUID\";\n\nexport const matchFx = (function () {\n  let fx = {};\n  let dfx = drawFx();\n\n  // create an array of ids of all players who are selected for any event\n  // used to prevent sign-out of approved players\n  // if dual matches then get a list of all players who are part of any defined match\n  fx.activeTeamPlayers = ({ tournament }) => {\n    if (!tc.isTeam({ tournament }) || !tournament.events) return [];\n    let {\n      completed_matches,\n      pending_matches,\n      upcoming_matches,\n    } = fx.tournamentEventMatches({ tournament });\n    let all_matches = [].concat(\n      ...pending_matches,\n      ...upcoming_matches,\n      completed_matches\n    );\n    return []\n      .concat(...all_matches.map((m) => m.players))\n      .map((p) => p && p.id)\n      .filter((f) => f);\n  };\n\n  fx.matchPlayers = ({ match, potentials }) => {\n    if (!match) return [];\n    let pc = !potentials\n      ? []\n      : flatten(\n          match.potentials || (match.match && match.match.potentials) || []\n        ).filter((f) => f && f.id);\n\n    let teams = flatten(\n      match.teams || (match.match && match.match.teams) || []\n    ).filter((f) => f.id);\n    if (teams.length) {\n      return flatten(teams.concat(...pc));\n    }\n\n    let players = flatten(\n      match.players || (match.match && match.match.players) || []\n    ).filter((f) => f && f.id);\n    if (players.length) {\n      return flatten(players.concat(...pc));\n    }\n\n    let winners = flatten(\n      match.winner || (match.match && match.match.winner) || []\n    ).filter((f) => f && f.id);\n    let losers = flatten(\n      match.loser || (match.match && match.match.loser) || []\n    ).filter((f) => f && f.id);\n\n    let match_players = pc.concat(...winners, ...losers);\n    console.log({ match_players });\n    return match_players;\n  };\n\n  fx.opponentsInclude = ({ match, potentials, ids }) => {\n    let opponents = fx.matchPlayers({ match, potentials }).filter((f) => f);\n    let include_ids = opponents.reduce(\n      (p, c) => ids.indexOf(c.id) >= 0 || p,\n      false\n    );\n    return include_ids;\n  };\n\n  fx.removeMatchSchedule = ({ e, tournament, opponent_ids, env }) => {\n    if (!e || !tournament || !opponent_ids) return;\n    let event_matches = eventMatches(e, tournament, false, env);\n    let match = event_matches.reduce(\n      (p, match) =>\n        fx.opponentsInclude({ match, ids: opponent_ids }) ? match : p,\n      undefined\n    );\n    if (match && match.schedule) match.schedule = {};\n    if (match && match.match && match.match.schedule) match.match.schedule = {};\n  };\n\n  // Returns NEW objects; modifications don't change originals\n  // if 'source' is true, then source object is included...\n  fx.tournamentEventMatches = tournamentEventMatches;\n  function tournamentEventMatches({ tournament, source, env }) {\n    if (!tournament.events)\n      return {\n        completed_matches: [],\n        pending_matches: [],\n        upcoming_matches: [],\n        total_matches: 0,\n      };\n\n    let total_matches = 0;\n    var completed_matches = [];\n    var pending_matches = [];\n    var upcoming_matches = [];\n\n    // don't sort tournament.events ... sort map of tournament draw types\n    function drawTypeSort(draw_type) {\n      return [\"R\", \"Q\"].indexOf(draw_type) >= 0 ? 0 : 1;\n    }\n    var ordered_events = tournament.events\n      .map((e, index) => ({ draw_type: e.draw_type, index }))\n      .sort((a, b) => drawTypeSort(a.draw_type) - drawTypeSort(b.draw_type));\n\n    ordered_events.forEach((oe) => {\n      let e = tournament.events[oe.index];\n      if (tc.isRoundRobin({ e })) dfx.roundRobinRounds({ event: e });\n      let { complete, incomplete, upcoming } = eventMatchStorageObjects({\n        tournament,\n        e,\n        source,\n        env,\n      });\n\n      if (tc.isRoundRobin({ e })) {\n        complete.sort(\n          (a, b) =>\n            a.round_name &&\n            b.round_name &&\n            a.round_name.localeCompare(b.round_name)\n        );\n        incomplete.sort(\n          (a, b) =>\n            a.round_name &&\n            b.round_name &&\n            a.round_name.localeCompare(b.round_name)\n        );\n        upcoming.sort(\n          (a, b) =>\n            a.round_name &&\n            b.round_name &&\n            a.round_name.localeCompare(b.round_name)\n        );\n      }\n      completed_matches = completed_matches.concat(...complete);\n      pending_matches = pending_matches.concat(...incomplete);\n      upcoming_matches = upcoming_matches.concat(...upcoming);\n    });\n\n    total_matches = completed_matches.length + pending_matches.length;\n\n    return {\n      completed_matches,\n      pending_matches,\n      upcoming_matches,\n      total_matches,\n    };\n  }\n\n  function eventMatchStorageObjects({ tournament, e, source, env }) {\n    if (!e.draw) return { complete: [], incomplete: [], upcoming: [] };\n\n    let event_matches = eventMatches(e, tournament, false, env);\n\n    // for Round Robin Draw to be considered qualification it needs to be linked to an Elimination Draw\n    let draw_format = e.draw.brackets ? \"round_robin\" : \"tree\";\n    if (draw_format === \"round_robin\" && (!e.links || !e.links[\"E\"])) {\n      event_matches.forEach((match) => {\n        if (match.round_name)\n          match.round_name = match.round_name.replace(\"Q\", \"\");\n      });\n    }\n\n    let complete = event_matches\n      .filter((f) => f.match && f.match.winner && f.match.loser)\n      .map((m) => matchStorageObject({ tournament, e, match: m, source }))\n      .filter((f) => f);\n\n    let incomplete = event_matches\n      .filter((f) => f.match && !f.match.winner && !f.match.loser)\n      .map((m) => matchStorageObject({ tournament, e, match: m, source }))\n      .filter(\n        (m) =>\n          (m.players && m.players.filter((f) => f).length) ||\n          (m.potentials && m.potentials.length)\n      );\n\n    let upcoming =\n      upcomingEventMatches({ e, tournament, env })\n        .map((m) => matchStorageObject({ tournament, e, match: m, source }))\n        .filter((f) => f) || [];\n\n    return { complete, incomplete, upcoming };\n  }\n\n  function matchStorageObject({ tournament, e, match, source }) {\n    if (!match.match) return;\n\n    let players = [];\n    let team_players;\n    let match_teams = safeArr(match.teams);\n\n    if (!match_teams.length) {\n      players = [];\n      team_players = [];\n    } else if (match.match.winner && match.match.winner[0]) {\n      let team0 = safeArr(match_teams[0]);\n      let team1 = safeArr(match_teams[1]);\n      players = [].concat(...team0, ...team1);\n      team_players = [\n        team0.map((p, i) => i),\n        team1.map((p, i) => team0.length + i),\n      ];\n    } else {\n      players = [].concat(...match_teams);\n      team_players = match_teams.map((t, i) =>\n        !t ? [null] : t.map((m, j) => i * t.length + j)\n      );\n    }\n\n    let coords;\n    let schedule = match.match.schedule;\n    if (schedule && schedule.luid && tournament.locations) {\n      let loc = tournament.locations.reduce(\n        (p, c) => (c.luid === schedule.luid ? c : p),\n        undefined\n      );\n      if (loc) coords = { latitude: loc.latitude, longitude: loc.longitude };\n    }\n\n    let matchFormat = match.match.matchFormat || e.matchFormat;\n\n    let obj = {\n      consolation: tc.isConsolation({ e }),\n      draw_positions: e.draw_size,\n      date: match.match.date,\n      schedule,\n      location: coords,\n      format:\n        tc.isDoubles({ match }) || tc.isDoubles({ e }) ? \"doubles\" : \"singles\",\n      gender: e.gender,\n      muid: match.match.muid,\n      ids: players.filter((p) => p).map((p) => p.id),\n\n      // TODO: These need object copy\n      players,\n      teams: match.teams,\n      set_scores: match.match.set_scores,\n\n      // TODO: should be => teams: team_players,\n      team_players,\n\n      dependent: match.dependent,\n      dependencies: match.dependencies,\n\n      // potential opponents for upcoming matches\n      potentials: match.potentials,\n\n      result_order: match.result_order,\n      round: match.round || match.match.round,\n      round_name: match.round_name || match.match.round_name,\n      calculated_round_name: match.calculated_round_name,\n\n      // all score related details should be stored in an object...\n      score: match.match.score,\n\n      matchFormat,\n      delegated_score: match.match.delegated_score,\n\n      status: match.match.status,\n      tournament: {\n        name: tournament.name,\n        tuid: tournament.tuid,\n        org: tournament.org,\n        start: tournament.start,\n        end: tournament.end,\n        rank: tournament.rank,\n      },\n      event: {\n        name: e.name,\n        rank: e.rank,\n        euid: e.euid,\n        surface: e.surface,\n        category: e.category,\n        draw_type: e.draw_type,\n        custom_category: e.custom_category,\n      },\n      dual_match: match.dual_match,\n      sequence: match.sequence,\n      umpire: match.match.umpire,\n\n      // TODO: can this be removed?\n      winner: match.match.winner_index,\n\n      winner_index: match.match.winner_index,\n    };\n\n    if (source) obj.source = match.match;\n    return obj;\n  }\n\n  fx.matchOutcome = matchOutcome;\n  function matchOutcome(match, id) {\n    let player_won = null;\n    let winning_ids = [];\n    let winning_team;\n    let losing_team;\n    let losing_ids = [];\n\n    // TODO: this is a patch for matches from database\n    // .teams needs to be updated to .team_players\n    if (!match.team_players) match.team_players = match.teams;\n\n    if (match.winner !== undefined) {\n      winning_team = match.team_players[match.winner]\n        .map((pindex) => {\n          let player = match.players[pindex];\n          winning_ids.push(player.id);\n          if (player.id === id) player_won = true;\n          return `${fullName(player)}${\n            player.rank ? \" [\" + player.rank + \"]\" : \"\"\n          }`;\n        })\n        .join(\"; \");\n\n      losing_team = match.team_players[1 - match.winner]\n        .map((pindex) => {\n          let player = match.players[pindex];\n          if (!player) return \"Undefined\";\n          losing_ids.push(player.id);\n          if (player.id === id) player_won = false;\n          return `${fullName(player)}${\n            player.rank ? \" [\" + player.rank + \"]\" : \"\"\n          }`;\n        })\n        .join(\"; \");\n    }\n\n    return { player_won, winning_team, losing_team, winning_ids, losing_ids };\n  }\n\n  function fullName(p) {\n    return `${p.last_name.toUpperCase()}, ${p.first_name}`;\n  }\n\n  fx.scheduledMatches = scheduledMatches;\n  function scheduledMatches({ tournament, env }) {\n    let {\n      completed_matches,\n      pending_matches,\n      upcoming_matches,\n    } = tournamentEventMatches({ tournament, source: true, env });\n    let all_matches = completed_matches.concat(\n      ...pending_matches,\n      ...upcoming_matches\n    );\n    let scheduled = all_matches.filter((m) => m.schedule && m.schedule.day);\n    let days = unique(scheduled.map((m) => m.schedule.day));\n    return { scheduled, days };\n  }\n\n  function upcomingEventMatches({ e, tournament, env }) {\n    if (!e.draw) return [];\n    if (tc.isTeam({ tournament, e })) return [];\n    let round_names = roundNames(tournament, e);\n    let matches = dfx.upcomingMatches(\n      e.draw,\n      round_names.names,\n      round_names.calculated_names\n    );\n    return checkScheduledMatches({ e, tournament, matches, env });\n  }\n\n  fx.dualMatchMatches = (e, muid) => {\n    if (!e.draw) return [];\n    if (!e.draw.dual_matches) return [];\n    if (muid && e.draw.dual_matches[muid]) {\n      return e.draw.dual_matches[muid].matches || [];\n    } else {\n      let matches = [];\n      Object.keys(e.draw.dual_matches || {}).forEach((key) => {\n        let dual_matches = e.draw.dual_matches[key].matches || [];\n        dual_matches.forEach((dm) => (dm.dual_match = key));\n        matches = matches.concat(...dual_matches);\n      });\n      return matches;\n    }\n  };\n\n  fx.eventMatches = eventMatches;\n  function eventMatches(e, tournament, all, env) {\n    let matches = [];\n    if (!e || !e.draw) {\n      return matches;\n    }\n    if (tc.isAdHoc({ e })) {\n      matches = safeArr(e.draw && e.draw.matches);\n    } else if (tc.isTeam({ tournament, e })) {\n      Object.keys(e.draw.dual_matches || {}).forEach((key) => {\n        let dual_matches = e.draw.dual_matches[key].matches || [];\n        dual_matches.forEach((dm) => (dm.dual_match = key));\n        matches = matches.concat(...dual_matches);\n      });\n    } else {\n      let round_names = roundNames(tournament, e);\n      matches = dfx.matches(\n        e.draw,\n        round_names.names,\n        round_names.calculated_names,\n        all\n      );\n    }\n    checkScheduledMatches({ e, tournament, matches, env });\n    return matches;\n  }\n\n  fx.containsGUIDplayer = (match) => {\n    let players =\n      match &&\n      ((match.match && match.match.players) ||\n        (match.teams && [].concat(...match.teams)));\n    let GUIDplayers =\n      players &&\n      players.reduce(\n        (p, c) =>\n          c && c.id && c.id.length >= 36 && c.id.split(\"-\").length === 5\n            ? true\n            : p,\n        false\n      );\n    return GUIDplayers;\n  };\n\n  function findEventByID(tournament, id) {\n    if (!tournament || !tournament.events || tournament.events.length < 1)\n      return;\n    return tournament.events.reduce(\n      (p, c) => (c.euid === id ? c : p),\n      undefined\n    );\n  }\n\n  fx.roundNames = roundNames;\n  function roundNames(tournament, e) {\n    var names = [];\n    var calculated_names = [];\n    if (tc.hasRoundNames({ e })) {\n      if (tc.isFeedIn({ e })) {\n        names = [\"F\", \"SF\", \"QF\"];\n        let depth = dfx.drawInfo(e.draw).depth;\n        if (depth > 3) {\n          let rounds = numArr(depth - 3)\n            .map((d) => `R${d + 1}`)\n            .reverse();\n          names = names.concat(...rounds);\n        }\n      } else {\n        names = [\"F\", \"SF\", \"QF\", \"R16\", \"R32\", \"R64\", \"R128\", \"R256\", \"R512\"];\n      }\n    }\n    if (tc.isQualifying({ e })) {\n      names = [\"Q\", \"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\"];\n      let qlink = e.links && findEventByID(tournament, e.links[\"E\"]);\n      if (qlink && qlink.draw) {\n        let info = dfx.drawInfo(qlink.draw);\n        if (info)\n          calculated_names = [\n            \"F\",\n            \"SF\",\n            \"QF\",\n            \"R16\",\n            \"R32\",\n            \"R64\",\n            \"R128\",\n            \"R256\",\n            \"R512\",\n            \"R1024\",\n          ].slice(info.depth);\n      }\n    }\n    if (tc.isPlayoff({ e })) {\n      names = [\"PO3\"];\n    }\n    return { names, calculated_names };\n  }\n\n  fx.checkScheduledMatches = checkScheduledMatches;\n  function checkScheduledMatches({ e, tournament, matches, env }) {\n    addMUIDs(e);\n\n    let court_names = {};\n    let max_matches_per_court =\n      (env && env.schedule.max_matches_per_court) || 14;\n    safeArr(tournament.locations)\n      .map((l) => l.luid)\n      .forEach((luid) =>\n        courtData(tournament, luid, max_matches_per_court).forEach(\n          (ct) => (court_names[ctuuid(ct)] = ct.name)\n        )\n      );\n    let check_names = Object.keys(court_names).length;\n\n    matches.forEach((match) => {\n      let schedule = match.match && match.match.schedule;\n      if (schedule) {\n        if (check_names) schedule.court = court_names[ctuuid(schedule)];\n        if (schedule && schedule.oop_round && schedule.luid) {\n          let court_matches = matches\n            .filter(\n              (m) =>\n                m.match &&\n                m.match.schedule &&\n                ctuuid(m.match.schedule) === ctuuid(schedule)\n            )\n            .filter(\n              (m) =>\n                m.match.schedule.oop_round < schedule.oop_round &&\n                m.match.winner === undefined\n            );\n          schedule.after = court_matches.length;\n        }\n        if (schedule.time) {\n          schedule.time = dateFx.convertTime(schedule.time, env);\n        }\n      }\n    });\n\n    return matches || [];\n  }\n\n  fx.eventRoundConsolationReady = ({ draw, round }) => {\n    let info = draw && dfx.drawInfo(draw);\n    if (!info || !round || isNaN(round)) return;\n    let round_matches = safeArr(info.all_matches).filter(\n      (f) => +f.height === +round\n    );\n    let with_team = round_matches.filter((m) => m && m.data && m.data.team);\n\n    return round_matches.length === with_team.length;\n  };\n\n  fx.getLuckyLosers = ({ tournament, evnt, env }) => {\n    let all_rounds = env.drawFx.ll_all_rounds;\n    let completed_matches =\n      (tournament &&\n        fx\n          .eventMatches(evnt, tournament, false, env)\n          .filter((m) => m.match.winner)) ||\n      [];\n    if (!all_rounds && tc.isQualifying({ e: evnt }))\n      completed_matches = completed_matches.filter(\n        (m) => m.match.round_name === \"Q\"\n      );\n    let losing_ids = [].concat(\n      ...completed_matches.map((match) =>\n        match.match.loser.map((team) => team.id)\n      )\n    );\n    let qualifying_ids =\n      (evnt &&\n        evnt.qualified &&\n        evnt.qualified.length &&\n        evnt.qualified.map((q) => q[0].id)) ||\n      [];\n    let losing_players =\n      (tournament &&\n        tournament.players.filter(\n          (p) =>\n            losing_ids.indexOf(p.id) >= 0 && qualifying_ids.indexOf(p.id) < 0\n        )) ||\n      [];\n    console.log({ qualifying_ids, losing_ids, losing_players });\n    return { losing_ids, losing_players };\n  };\n\n  fx.addMUIDs = addMUIDs;\n  function addMUIDs(e) {\n    if (!e.draw) return;\n    let current_draw = e.draw.compass ? e.draw[e.draw.compass] : e.draw;\n    if (!current_draw) return;\n\n    if (e.draw.compass) {\n      dfx.compassInfo(e.draw).all_matches.forEach(addMUID);\n    } else if (e.draw.brackets) {\n      e.draw.brackets.forEach((bracket) =>\n        bracket.matches.forEach((match) => {\n          if (!match.muid) match.muid = UUID.new();\n          match.euid = e.euid;\n        })\n      );\n    } else {\n      let info = dfx.drawInfo(current_draw);\n      if (info && info.nodes) info.nodes.forEach(addMUID);\n    }\n\n    function addMUID(node) {\n      let muid = (node.data && node.data.nuid) || UUID.new();\n      if (node.children) {\n        if (!node.data.match) node.data.match = {};\n        if (!node.data.match.muid) node.data.match.muid = muid;\n        if (!node.data.match.euid) node.data.match.euid = e.euid;\n      }\n    }\n  }\n\n  fx.determineGender = (match) => {\n    let genders = match.players\n      ? match.players\n          .filter((f) => f)\n          .map((p) => p.sex)\n          .filter((f) => f)\n          .filter((item, i, s) => s.lastIndexOf(item) === i)\n      : [];\n    return !genders.length ? \"\" : genders.length > 1 ? \"X\" : genders[0];\n  };\n\n  fx.matchTime = (match, env) =>\n    (match.schedule &&\n      match.schedule.time &&\n      dateFx.convertTime(match.schedule.time, env)) ||\n    \"\";\n  fx.matchRound = (match) => match.round_name || match.round;\n  fx.matchDate = (match) => {\n    if (match.schedule && match.schedule.day)\n      return datePDF(new Date(match.schedule.day));\n    if (match.date) return datePDF(match.date);\n    return \"\";\n  };\n\n  fx.matchDesignator = ({ tournament, match }) => {\n    let evt =\n      match && match.event && findEventByID(tournament, match.event.euid);\n    let category = (evt && evt.category && evt.category.slice(0, 4)) || \"\";\n    return `${evt.gender}${evt.format}${category}`;\n  };\n\n  fx.matchDateDisplay = (match) => {\n    if (match.schedule && match.schedule.day)\n      return displayDate(new Date(match.schedule.day));\n    if (match.date) return displayDate(match.date);\n    return \"\";\n  };\n\n  fx.matchDuration = (match) => {\n    if (match.schedule && match.schedule.start && match.schedule.end) {\n      let d = duration(match.schedule.start, match.schedule.end);\n      return `<b>${d}</b>`;\n    }\n    return \"\";\n\n    function duration(start, end) {\n      var seconds = getSeconds(end) - getSeconds(start);\n      if (seconds <= 0) seconds = getSeconds(end, 12) - getSeconds(start);\n      if (seconds <= 0) seconds = getSeconds(end, 12) - getSeconds(start, -12);\n      var hours = Math.floor(seconds / (60 * 60));\n      var minutes = Math.floor(seconds - hours * 60 * 60) / 60;\n      return `${zeroPad(hours)}:${zeroPad(minutes)}`;\n    }\n    function getSeconds(hm, mod = 0) {\n      var a = hm.split(\":\");\n      var getNum = (x) => (x && !isNaN(x) ? +x : 0);\n      var hours = getNum(a[0]) + mod;\n      var minutes = getNum(a[1]);\n      return hours * 60 * 60 + minutes * 60;\n    }\n  };\n\n  fx.roundPosition = ({ match, info, backdrawTarget }) => {\n    let all_matches = info && info.all_matches;\n    let match_node =\n      all_matches &&\n      all_matches.reduce(\n        (p, n) => (n.data?.match?.muid === match?.muid ? n : p),\n        undefined\n      );\n    let match_round =\n      all_matches &&\n      all_matches.filter((n) => match_node && match_node.depth === n.depth);\n    let backdraw_target =\n      all_matches &&\n      all_matches.filter(\n        (n) => match_node && !dfx.byeNode(n) && match_node.depth === n.depth\n      );\n\n    let round = backdrawTarget ? backdraw_target : match_round;\n\n    let muids =\n      round &&\n      round\n        .map((n) => n && n.data && n.data.match && n.data.match.muid)\n        .filter((f) => f);\n    let index = muids && muids.indexOf(match?.muid);\n    return index >= 0 ? (index + 1).toString() : \"\";\n  };\n\n  fx.roundNumber = ({ match, info, DrawStructure }) => {\n    let all_matches = info && info.all_matches;\n    let match_node =\n      all_matches &&\n      all_matches.reduce(\n        (p, n) => (n.data?.match?.muid === match?.muid ? n : p),\n        undefined\n      );\n    let match_node_depth = (match_node && match_node.depth) || 0;\n    let round = info && info.depth ? info.depth - match_node_depth : \"\";\n    let rr_round = DrawStructure === \"ROUND-ROBIN\" ? match.round : \"\";\n    return (round || rr_round || \"\").toString();\n  };\n\n  fx.matchFinish = (match) => {\n    return match.schedule && match.schedule.end ? match.schedule.end : \"\";\n  };\n  fx.matchCourt = (match) => {\n    return (match.schedule && match.schedule.court) || \"\";\n  };\n\n  fx.matchScore = (match, non_breaking) => {\n    let scr = match.score || match.delegated_score || \"\";\n    if (match.winner_index === 1) scr = scoreFx.reverseScore(scr);\n    // eslint-disable-next-line no-useless-escape\n    return scr && non_breaking ? scr.replace(/\\-/g, \"&#8209;\") : scr;\n  };\n\n  fx.isByeMatch = (match) =>\n    match &&\n    match.players &&\n    match.players\n      .filter((f) => f)\n      .reduce((p, c) => (c.bye ? true : p), undefined);\n  fx.idInMatch = ({ match, id }) =>\n    match &&\n    match.players &&\n    match.players.reduce((p, c) => (c.id === id ? true : p), undefined);\n\n  function datePDF(timestamp) {\n    console.log({ timestamp });\n    let date = dateFx.offsetDate(timestamp);\n    return [zeroPad(date.getMonth() + 1), zeroPad(date.getDate())].join(\"-\");\n  }\n\n  function displayDate(timestamp) {\n    let date = dateFx.offsetDate(timestamp);\n    return [zeroPad(date.getMonth() + 1), zeroPad(date.getDate())].join(\n      \"&#8209;\"\n    );\n  }\n\n  return fx;\n})();\n\nfunction numArr(count) {\n  return [...Array(count)].map((_, i) => i);\n}\nfunction zeroPad(number) {\n  return number.toString()[1] ? number : \"0\" + number;\n}\nfunction unique(arr) {\n  return arr.filter((item, i, s) => s.lastIndexOf(item) === i);\n}\nfunction safeArr(x) {\n  return (\n    (Array.isArray(x) && x) ||\n    (typeof x === \"object\" && Object.keys(x).map((k) => x[k])) ||\n    []\n  );\n}\nfunction flatten(arr) {\n  return arr.reduce(\n    (flat, toFlatten) =>\n      flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten),\n    []\n  );\n}\n","import { drawDefinitionConstants } from \"tods-competition-factory\";\nimport { tournamentEngine } from \"tods-competition-factory\";\nimport { extractMatchUp } from \"./extractMatchUp\";\nimport { getStage } from \"./utilities\";\nimport { matchFx } from \"./matchFx\";\nimport { drawFx } from \"./drawFx\";\nimport { UUID } from \"./UUID\";\n\nconst { CONTAINER, ITEM, ROUND_OUTCOME, WIN_RATIO } = drawDefinitionConstants;\n\nconst dfx = drawFx();\n\nexport function getStructureContent({\n  eventType,\n  tieFormat,\n  tournament,\n  legacyEvent,\n  participants,\n}) {\n  const legacyDual = tournament.type === \"dual\";\n  const totalPlayers =\n    legacyEvent.approved.length + (legacyEvent.qualifiers || 0) ||\n    legacyEvent.feed_base ||\n    legacyEvent.draw_size;\n  const seedLimit = dfx.seedLimit({\n    total_players: totalPlayers,\n    evt: legacyEvent,\n  });\n\n  const entryStage = getStage({ legacyEvent });\n  const info = dfx.drawInfo(legacyEvent.draw);\n\n  const props = {\n    participants,\n    legacyEvent,\n    tournament,\n    legacyDual,\n    seedLimit,\n    entryStage,\n    tieFormat,\n    eventType,\n    info,\n  };\n\n  const result = legacyEvent?.draw?.brackets\n    ? roundRobinStructure(props)\n    : eliminationStructure(props);\n\n  return result;\n}\n\nfunction eliminationStructure({\n  legacyEvent,\n  tournament,\n  tieFormat,\n  legacyDual,\n  seedLimit,\n  entryStage,\n  participants,\n  eventType,\n  info,\n}) {\n  // logic for elmination structures\n  const eventMatches = matchFx.eventMatches(legacyEvent, tournament, true);\n  // if tournament type is dual then matches need to be retrieved differently\n  const roundNames = matchFx.roundNames(tournament, legacyEvent);\n  const dfxMatches = dfx.matches(\n    legacyEvent.draw,\n    roundNames.names,\n    roundNames.calculated_names,\n    true\n  );\n  const matches = legacyDual ? dfxMatches : eventMatches;\n  const tieMatches = (legacyDual && eventMatches) || [];\n  const positionAssignments = [];\n  const seedAssignments = [];\n  const participantIds = [];\n  const entries = [];\n\n  const matchUpFormat = legacyEvent.matchFormat;\n\n  const matchUps = matches\n    .map((legacyMatch) => {\n      const result = processLegacyMatch({\n        entries,\n        tieFormat,\n        eventType,\n        matchUpFormat,\n        seedAssignments,\n\n        tieMatches,\n        legacyMatch,\n        participantIds,\n        participants,\n        entryStage,\n        seedLimit,\n        info,\n      });\n      if (result) {\n        const { matchUp, positionAssignments: matchUpAssignments } = result;\n        if (matchUpAssignments) positionAssignments.push(...matchUpAssignments);\n        return matchUp;\n      }\n      return undefined;\n    })\n    .filter((f) => f);\n\n  positionAssignments.sort((a, b) =>\n    a.drawPosition > b.drawPosition ? 1 : -1\n  );\n  seedAssignments.sort((a, b) => (a.seedNumber > b.seedNumber ? 1 : -1));\n\n  return {\n    entries,\n    matchUps,\n    seedLimit,\n    positionAssignments,\n    seedAssignments,\n    finishingPosition: ROUND_OUTCOME,\n  };\n}\n\nfunction roundRobinStructure({\n  tournament,\n  legacyEvent,\n  legacyDual,\n  participants,\n  entryStage,\n  seedLimit,\n  tieFormat,\n  eventType,\n  info,\n}) {\n  const eventMatches = matchFx.eventMatches(legacyEvent, tournament, true);\n  const tieMatches = (legacyDual && eventMatches) || [];\n\n  const structures = [];\n  const seedAssignments = [];\n  const participantIds = [];\n  const entries = [];\n\n  const matchUpFormat = legacyEvent.matchFormat;\n\n  legacyEvent.draw.brackets.forEach((bracket, index) => {\n    const drawPositionOffset = index * (legacyEvent.draw.bracket_size || 0);\n    const positionAssignments = [];\n    const matchUps = bracket.matches\n      .map((legacyMatch) => {\n        const result = processLegacyMatch({\n          seedAssignments,\n          entries,\n          eventType,\n          tieFormat,\n          matchUpFormat,\n          drawPositionOffset,\n          participantIds,\n          participants,\n          legacyMatch,\n          tieMatches,\n          entryStage,\n          seedLimit,\n          info,\n        });\n        if (result) {\n          const { matchUp, positionAssignments: matchUpAssignments } = result;\n          if (matchUpAssignments)\n            positionAssignments.push(...matchUpAssignments);\n          return matchUp;\n        }\n        return undefined;\n      })\n      .filter((f) => f);\n    const structureName = bracket.name || `Group ${index + 1}`;\n    const structure = {\n      structureType: ITEM,\n      structureId: UUID.generate(),\n      stageSequence: 1,\n      positionAssignments,\n      structureName,\n      matchUps,\n    };\n    structures.push(structure);\n  });\n\n  return {\n    entries,\n    seedLimit,\n    structures,\n    seedAssignments: [],\n    structureType: CONTAINER,\n    finishingPosition: WIN_RATIO,\n  };\n}\n\nfunction processLegacyMatch({\n  seedAssignments,\n  matchUpFormat,\n  tieFormat,\n  eventType,\n  entries,\n\n  drawPositionOffset,\n  participantIds,\n  participants,\n  legacyMatch,\n  tieMatches,\n  entryStage,\n  seedLimit,\n  info,\n}) {\n  const positionAssignments = [];\n  const isDualMatch = !!legacyMatch.dual_match;\n  const matchUpId = legacyMatch.match?.muid || legacyMatch.muid;\n  if (!legacyMatch.teams || isDualMatch) {\n    return {};\n  }\n\n  const roundNumberString =\n    matchFx.roundNumber({\n      match: legacyMatch.match,\n      info,\n    }) ||\n    legacyMatch.match?.round ||\n    legacyMatch?.round;\n  const roundNumber = !isNaN(parseInt(roundNumberString))\n    ? parseInt(roundNumberString)\n    : undefined;\n  const roundPositionString = matchFx.roundPosition({\n    match: legacyMatch.match,\n    info,\n  });\n  const roundPosition = !isNaN(parseInt(roundPositionString))\n    ? parseInt(roundPositionString)\n    : undefined;\n  const roundName =\n    legacyMatch.match?.calculated_round_name ||\n    legacyMatch.match?.round_name ||\n    legacyMatch?.round_name ||\n    \"\";\n\n  const tieMatchUps = tieMatches\n    .filter((tieMatch) => tieMatch.dual_match === matchUpId)\n    .map((tieMatch) => {\n      const { matchUp, missingParticipants } = extractMatchUp({\n        info,\n        tieFormat,\n        eventType,\n        seedLimit,\n        entryStage,\n        participants,\n        participantIds,\n        tournamentEngine,\n        legacyMatch: tieMatch,\n      });\n      Object.assign(matchUp, { roundName, roundNumber, roundPosition });\n      if (missingParticipants.length) console.log({ missingParticipants });\n      return matchUp;\n    });\n\n  const {\n    matchUp,\n    missingParticipants,\n    positionAssignments: matchUpPositionAssignments,\n    seedAssignments: matchUpSeedAssignments,\n    entries: matchUpEntries,\n  } = extractMatchUp({\n    info,\n    eventType,\n    seedLimit,\n    entryStage,\n    legacyMatch,\n    participants,\n    matchUpFormat,\n    participantIds,\n    tournamentEngine,\n    drawPositionOffset,\n  });\n  if (missingParticipants?.filter((f) => f).length)\n    console.log({ missingParticipants });\n\n  if (tieMatchUps) {\n    tieMatchUps.forEach((tieMatchUp) => {\n      const { collectionPosition, matchUpType, sides } = tieMatchUp;\n      const collectionDefinition = tieFormat?.collectionDefinitions.find(\n        (collectionDefinition) =>\n          collectionDefinition.matchUpType === matchUpType\n      );\n      const collectionId = collectionDefinition?.collectionId;\n      if (sides?.length) {\n        sides.forEach(({ participantId, sideNumber }) => {\n          const side = matchUp.sides.find(\n            (side) => side.sideNumber === sideNumber\n          );\n          if (!side.lineUp) side.lineUp = [];\n          const competitor = side.lineUp.find(\n            (competitor) => competitor.participantId === participantId\n          );\n          if (competitor) {\n            competitor.collectionAssignments.push({\n              collectionId,\n              collectionPosition,\n            });\n          } else {\n            const competitor = {\n              participantId,\n              collectionAssignments: [{ collectionId, collectionPosition }],\n            };\n            side.lineUp.push(competitor);\n          }\n        });\n      }\n    });\n  }\n\n  matchUpPositionAssignments.forEach((positionAssignment) =>\n    positionAssignments.push(positionAssignment)\n  );\n  matchUpSeedAssignments.forEach((seedAssignment) =>\n    seedAssignments.push(seedAssignment)\n  );\n  matchUpEntries.forEach((entry) => entries.push(entry));\n\n  Object.assign(matchUp, { roundName, roundNumber, roundPosition });\n  if (tieMatchUps.length) {\n    Object.assign(matchUp, { tieMatchUps });\n  }\n\n  return { matchUp, positionAssignments };\n}\n","import { convertTieFormat } from \"./convertTieFormat\";\nimport { extractStructures } from \"./extractStructures\";\nimport { matchFormatCode } from \"./matchFormatCode\";\nimport { scoreFormat } from \"./scoreFormat\";\nimport {\n  tournamentEngine,\n  factoryConstants,\n  matchUpTypes,\n  utilities,\n} from \"tods-competition-factory\";\n\nimport {\n  getGender,\n  getSurface,\n  intersection,\n  getMatchUpType,\n  getIndoorOutdoor,\n  getAgeCategoryCode,\n} from \"./utilities\";\n\nexport function extractEvents({ tournament, participants }) {\n  const eventCategories = {};\n  const legacyEvents = tournament.events || [];\n  const tournamentRecord = { participants, tournamentId: \"foo\" };\n  tournamentEngine.setState(tournamentRecord);\n\n  // linkedStructures are events which have explicit links\n  const linkedStructures = {};\n\n  legacyEvents.forEach((legacyEvent) => {\n    const euid = legacyEvent.euid;\n    const eventIds = [euid];\n    legacyEvent.links &&\n      Object.keys(legacyEvent.links).forEach((key) => {\n        const linkedEuid = legacyEvent.links[key];\n        eventIds.push(linkedEuid);\n      });\n    const groupEuid = intersection(Object.keys(linkedStructures), eventIds);\n    if (groupEuid.length) {\n      linkedStructures[groupEuid[0]][euid] = legacyEvent;\n    } else {\n      linkedStructures[euid] = { [euid]: legacyEvent };\n    }\n  });\n\n  Object.keys(linkedStructures).forEach((key) => {\n    const structureGroup = linkedStructures[key];\n    const structureGroupIds = Object.keys(structureGroup);\n    const groupStructures = structureGroupIds.map((id) => structureGroup[id]);\n    const structureGroupDrawTypes = groupStructures.map(\n      (event) => event.draw_type\n    );\n    const mainDrawTypes = [\"E\", \"S\"];\n    if (!intersection(mainDrawTypes, structureGroupDrawTypes).length) {\n      if (structureGroupDrawTypes.includes(\"R\")) mainDrawTypes.push(\"R\");\n      else if (structureGroupDrawTypes.includes(\"A\")) mainDrawTypes.push(\"A\");\n      else if (structureGroupDrawTypes.includes(\"C\")) mainDrawTypes.push(\"C\");\n      else if (structureGroupDrawTypes.includes(\"Q\")) mainDrawTypes.push(\"Q\");\n      else if (structureGroupDrawTypes.includes(\"P\")) mainDrawTypes.push(\"P\");\n      else console.log(\"unlinked event\", { structureGroup });\n    }\n    const mainLegacyEvent = groupStructures.find((legacyEvent) =>\n      mainDrawTypes.includes(legacyEvent.draw_type)\n    );\n    const eventType =\n      getMatchUpType(mainLegacyEvent.format) ||\n      ((mainLegacyEvent.matchorder || tournament.type === \"dual\") &&\n        matchUpTypes.TEAM);\n    const ageCategoryCode = getAgeCategoryCode(mainLegacyEvent.category);\n    const category = { categoryName: mainLegacyEvent.category };\n    if (ageCategoryCode) category.ageCategoryCode = ageCategoryCode;\n\n    const {\n      name,\n      automated,\n      draw_size,\n      matchorder,\n      draw_created,\n      broadcast_name,\n      custom_category,\n      category: legacyCategory,\n    } = mainLegacyEvent;\n\n    const tieFormat =\n      mainLegacyEvent.matchorder && convertTieFormat(matchorder);\n\n    const format = mainLegacyEvent.score_format;\n    const matchUpFormat =\n      mainLegacyEvent.matchFormat ||\n      (format && matchFormatCode.stringify(scoreFormat.jsonTODS(format)));\n\n    const { structures, drawEntries: entries } = extractStructures({\n      eventType,\n      tieFormat,\n      tournament,\n      participants,\n      matchUpFormat,\n      mainStructureId: mainLegacyEvent.euid,\n      legacyEvents: groupStructures,\n    });\n\n    const drawDefinition = {\n      // entries for a drawDefinition needs to be aggregated from structures\n      drawId: utilities.UUID(),\n      drawName:\n        custom_category ||\n        broadcast_name ||\n        name ||\n        factoryConstants.drawDefinitionConstants.MAIN,\n      createdAt: draw_created && new Date(draw_created).toISOString(),\n      structures,\n      entries,\n    };\n\n    if (matchUpFormat) drawDefinition.matchUpFormat = matchUpFormat;\n\n    const drawProfile = {\n      automated,\n      drawSize: draw_size,\n      category: { categoryName: legacyCategory },\n    };\n\n    if (tieFormat) {\n      drawDefinition.tieFormat = tieFormat;\n      drawProfile.tieFormat = tieFormat;\n    }\n\n    const extension = {\n      name: \"drawProfile\",\n      value: drawProfile,\n    };\n    tournamentEngine.addDrawDefinitionExtension({ drawDefinition, extension });\n\n    const eventId = utilities.UUID();\n    const surfaceCategory = getSurface(mainLegacyEvent);\n    const indoorOutdoor = getIndoorOutdoor(mainLegacyEvent);\n    const gender = getGender(mainLegacyEvent.gender);\n    const eventRank = mainLegacyEvent.rank;\n\n    const categoryName = `${category.categoryName}-${gender}-${eventType}`;\n    if (!eventCategories[categoryName]) {\n      eventCategories[categoryName] = {\n        gender,\n        eventId,\n        category,\n        eventType,\n        eventRank,\n        eventName: categoryName,\n        drawDefinitions: [drawDefinition],\n      };\n      if (indoorOutdoor)\n        eventCategories[categoryName].indoorOutdoor = indoorOutdoor;\n      if (surfaceCategory)\n        eventCategories[categoryName].surfaceCategory = surfaceCategory;\n    } else {\n      eventCategories[categoryName].drawDefinitions.push(drawDefinition);\n      if (indoorOutdoor && !eventCategories[categoryName].indoorOutdoor)\n        eventCategories[categoryName].indoorOutdoor = indoorOutdoor;\n      if (surfaceCategory && !eventCategories[categoryName].surfaceCategory)\n        eventCategories[categoryName].surfaceCategory = surfaceCategory;\n    }\n  });\n\n  const events = Object.values(eventCategories);\n  events.forEach((event) => {\n    const entriesAccumulator = {};\n    event.drawDefinitions.forEach((drawDefinition) => {\n      drawDefinition.entries.forEach((entry) => {\n        entriesAccumulator[entry.participantId] = entry;\n      });\n    });\n    event.entries = Object.values(entriesAccumulator);\n  });\n\n  return { events };\n}\n","import { utilities } from \"tods-competition-factory\";\n\nexport function convertTieFormat(matchorder) {\n  const matchUpTypes = utilities.unique(\n    matchorder.map(({ format }) => format.toUpperCase())\n  );\n  const collectionDefinitions = matchUpTypes.map((matchUpType) => {\n    const collectionMatchUps = matchorder.filter(\n      (order) => order.format.toUpperCase() === matchUpType\n    );\n    const collectionValue =\n      collectionMatchUps\n        ?.map(({ value }) => parseFloat(value))\n        .filter((value) => !isNaN(value))\n        .reduce((a, b) => a + b, 0) || 0;\n\n    const collectionValueProfile = (collectionMatchUps || []).map(\n      (matchUp, index) => ({\n        collectionPosition: index + 1,\n        matchUpValue: parseFloat(matchUp.value),\n      })\n    );\n    const collectionDefinition = {\n      matchUpsCount: collectionMatchUps.length,\n      collectionName: matchUpType,\n      collectionId: utilities.UUID(),\n      collectionValue,\n      matchUpType,\n    };\n\n    const valuesDiffer =\n      utilities.unique(\n        collectionValueProfile.map(({ matchUpValue }) => matchUpValue)\n      ).length > 1;\n\n    if (valuesDiffer) {\n      // if not all collection matchUpValues are equal, add collectionValueProfile...\n      collectionDefinition.collectionValueProfile = collectionValueProfile;\n    } else {\n      // ...otherwise just add matchUpValue\n      collectionDefinition.matchUpValue =\n        collectionValueProfile[0].matchUpValue;\n    }\n\n    return collectionDefinition;\n  });\n\n  const totalTieValue = collectionDefinitions\n    .map(({ collectionValue }) => collectionValue)\n    .reduce((a, b) => a + b);\n\n  // TMX 1.9 valueGoals were always 1 more than half\n  const valueGoal = Math.floor(totalTieValue / 2) + 1;\n  const winCriteria = { valueGoal };\n\n  return { collectionDefinitions, winCriteria };\n}\n","import { drawDefinitionConstants } from \"tods-competition-factory\";\nimport { matchFormatCode } from \"./matchFormatCode\";\nimport { scoreFormat } from \"./scoreFormat\";\nimport { getStructureContent } from \"./getStructureContent\";\nimport { getStage } from \"./utilities\";\n\nexport function extractStructures({\n  eventType,\n  tieFormat,\n  tournament,\n  participants,\n  legacyEvents,\n  matchUpFormat,\n  mainStructureId,\n}) {\n  const entriesAccumulator = {};\n  const structures = legacyEvents.map((legacyEvent) => {\n    const {\n      entries,\n      matchUps,\n      seedLimit,\n      structures,\n      structureType,\n      finishingPosition,\n      seedAssignments,\n      positionAssignments,\n    } = getStructureContent({\n      eventType,\n      tieFormat,\n      tournament,\n      legacyEvent,\n      participants,\n    });\n    entries.forEach((entry) => {\n      entriesAccumulator[entry.participantId] = entry;\n    });\n\n    const stage =\n      legacyEvent.euid === mainStructureId\n        ? drawDefinitionConstants.MAIN\n        : getStage({ legacyEvent });\n\n    const structure = {\n      stage,\n      matchUps,\n      seedLimit,\n      finishingPosition,\n      seedAssignments,\n      positionAssignments,\n      stageSequence: 1,\n      structureId: legacyEvent.euid,\n      structureName: legacyEvent.name,\n    };\n    if (structures) structure.structures = structures;\n    if (structureType) structure.structureType = structureType;\n\n    const format = legacyEvent.score_format;\n    const formatCode =\n      legacyEvent.matchFormat ||\n      (format && matchFormatCode.stringify(scoreFormat.jsonTODS(format)));\n    if (formatCode || matchUpFormat)\n      structure.matchUpFormat = formatCode || matchUpFormat;\n\n    return structure;\n  });\n\n  const drawEntries = Object.values(entriesAccumulator);\n  return { structures, drawEntries };\n}\n","import { normalizeName } from \"normalize-text\";\nimport { getGender } from \"./utilities\";\nimport { matchFx } from \"./matchFx\";\nimport { format } from \"date-fns\";\nimport { drawFx } from \"./drawFx\";\n\nimport {\n  errorConditionConstants,\n  participantConstants,\n  participantRoles,\n  penaltyConstants,\n  scaleConstants,\n  utilities,\n} from \"tods-competition-factory\";\n\nconst dfx = drawFx();\n\nexport function extractParticipants({ tournament, file }) {\n  const individualParticipants = extractIndividualParticipants({ tournament });\n\n  const pairParticipants = extractPairParticipants({\n    participants: individualParticipants,\n    tournament,\n    file,\n  });\n\n  const teamParticipants = extractTeamParticipants({\n    tournament,\n    file,\n  });\n\n  const competitorParticipants = individualParticipants.concat(\n    ...pairParticipants,\n    ...teamParticipants\n  );\n\n  return { competitorParticipants };\n}\n\nfunction extractTeamParticipants({ tournament, file }) {\n  const teamParticipants = (tournament.teams || []).map((team) => {\n    const individualParticipantIds = Object.keys(team.players);\n    const teamParticipant = {\n      participantId: team.id,\n      participantType: participantConstants.TEAM,\n      participantRole: participantRoles.COMPETITOR,\n      individualParticipantIds,\n      participantName: team.name,\n    };\n    return teamParticipant;\n  });\n\n  return teamParticipants;\n}\n\nfunction extractPairParticipants({ tournament, participants, file }) {\n  const pairParticipants = [];\n  const legacyEvents = tournament.events || [];\n  const legacyDual = tournament.type === \"dual\";\n  const relevantEvents = legacyEvents.filter(\n    (legacyEvent) => legacyEvent.format === \"D\" || legacyDual\n  );\n  relevantEvents.forEach((legacyEvent) => {\n    const matches = matchFx.eventMatches(legacyEvent, tournament, true);\n    const teams = matches.map((match) => match.teams).flat();\n    teams\n      .filter((team) => Array.isArray(team) && team.length === 2)\n      .forEach((team) => {\n        const individualParticipants = team\n          .map((player) =>\n            participants.find((participant) => {\n              const matchingParticipantId =\n                participant.participantId === player?.id;\n              const foundInOtherIds = participant?.person?.personOtherIds?.find(\n                (otherId) => otherId.personId === player?.id\n              );\n              return matchingParticipantId || foundInOtherIds;\n            })\n          )\n          .filter((f) => f);\n        if (individualParticipants.length === 2) {\n          const participantName = individualParticipants\n            .map((participant) => participant.person.standardFamilyName)\n            .join(\"/\");\n          const individualParticipantIds = individualParticipants.map(\n            (participant) => participant.participantId\n          );\n          const pairParticipant = {\n            participantId: utilities.UUID(),\n            participantType: participantConstants.PAIR,\n            participantRole: participantRoles.COMPETITOR,\n            individualParticipantIds,\n            participantName,\n          };\n          pairParticipants.push(pairParticipant);\n        }\n      });\n  });\n\n  return pairParticipants;\n}\n\nfunction extractIndividualParticipants({ tournament }) {\n  const individualParticipants = [];\n  const individualParticipantIds = [];\n  const players = tournament.players || [];\n\n  const tournamentStartDate =\n    tournament.start && format(new Date(tournament.start), \"yyyy-MM-dd\");\n  const tournamentCategory = tournament.category;\n  const organisationId = tournament.org?.ouid;\n\n  function addParticipant(player) {\n    const participantId = player.id || player.puid;\n    const standardFamilyName = getName(player.last_name);\n    const standardGivenName = getName(player.first_name);\n    const participantName = `${standardFamilyName.toUpperCase()}, ${standardGivenName}`;\n    const birthDate =\n      isValidDate(player.birth) && format(new Date(player.birth), \"yyyy-MM-dd\");\n\n    const participant = {\n      participantName,\n      participantId,\n      participantType: participantConstants.INDIVIDUAL,\n      participantRole: participantRoles.COMPETITOR,\n      timeItems: [],\n      person: {\n        personId: participantId,\n        standardFamilyName,\n        standardGivenName,\n        sex: getGender(player.sex),\n        nationalityCode: player.ioc,\n        birthDate,\n        otherNames: [],\n      },\n    };\n\n    addSignInStatus({ player, participant, tournamentStartDate });\n    addOtherNames({ player, participant });\n    addOtherIds({ player, participant, organisationId });\n    addRankings({\n      player,\n      participant,\n      tournamentStartDate,\n      tournamentCategory,\n    });\n    addRatings({ player, participant, tournamentStartDate });\n    addPenalties({ player, participant, tournamentStartDate });\n\n    if (!individualParticipantIds.includes(participant.participantId)) {\n      individualParticipants.push(participant);\n      individualParticipantIds.push(participantId);\n    }\n  }\n\n  players.forEach(addParticipant);\n\n  const relevantEvents = tournament.events?.filter((event) => event.draw) || [];\n  // check that there are no individual participants in draws that are not in tournament.players\n  relevantEvents.forEach((event) => {\n    const matches = dfx.matches(event.draw);\n    const players = matches.map((matchUp) => matchUp.teams).flat(Infinity);\n    // players which have .players are team participants\n    players.filter((f) => f && !f.players).forEach(addParticipant);\n  });\n\n  return individualParticipants;\n}\n\nfunction isValidDate(date) {\n  if (!date) return;\n  try {\n    const dateObject = new Date(date);\n    if (dateObject.trim() === errorConditionConstants.INVALID_DATE) {\n      return false;\n    }\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction getName(text) {\n  return normalizeName(text || \"\", [\"de\", \"la\", \"da\"]);\n}\n\nfunction addOtherNames({ player, participant }) {\n  if (player.nickname) participant.person.otherNames.push(player.nickname);\n}\nfunction addOtherIds({ player, participant, organisationId }) {\n  if (player.cropin) {\n    const personOtherIds = [\n      {\n        organisationId,\n        uniqueOrganisationName: \"HTS\",\n        personId: player.cropin,\n      },\n    ];\n    participant.person.personOtherIds = personOtherIds;\n  }\n  if (player.id && player.puid && player.puid !== player.id) {\n    if (!participant.person.personOtherIds)\n      participant.person.personOtherIds = [];\n    const otherId = {\n      organisationId,\n      uniqueOrganisationName: \"System\",\n      personId: player.puid,\n    };\n    participant.person.personOtherIds.push(otherId);\n  }\n}\n\nfunction addRankings({\n  player,\n  participant,\n  tournamentStartDate,\n  tournamentCategory,\n}) {\n  if (player.rankings) {\n    Object.keys(player.rankings).forEach((key) => {\n      const itemType = `${scaleConstants.SCALE}.${scaleConstants.RANKING}.SINGLES.${key}`;\n      const timeItem = {\n        itemType,\n        itemValue: player.rankings[key],\n        timestamp: tournamentStartDate,\n      };\n      participant.timeItems.push(timeItem);\n    });\n  }\n  if (player.category_dbls && tournamentCategory) {\n    const itemType = `${scaleConstants.SCALE}.${scaleConstants.RANKING}.SINGLES.${tournamentCategory}`;\n    const timeItem = {\n      itemType,\n      itemValue: player.category_dbls,\n      timestamp: tournamentStartDate,\n    };\n    participant.timeItems.push(timeItem);\n  }\n}\n\nfunction addRatings({ player, participant, tournamentStartDate }) {\n  if (player.ratings) {\n    Object.keys(player.ratings).forEach((key) => {\n      Object.keys(player.ratings[key]).forEach((ratingType) => {\n        const itemType = `${scaleConstants.SCALE}.${\n          scaleConstants.RATING\n        }.${ratingType.toUpperCase()}.${key.toUpperCase()}`;\n        const timeItem = {\n          itemType,\n          itemValue: player.ratings[key][ratingType].value,\n          timestamp: tournamentStartDate,\n        };\n        if (timeItem.itemValue) participant.timeItems.push(timeItem);\n      });\n    });\n  }\n}\n\nfunction addSignInStatus({ player, participant, tournamentStartDate }) {\n  const itemValue = player.signed_in\n    ? participantConstants.SIGNED_IN\n    : participantConstants.SIGNED_OUT;\n  const timeItem = {\n    itemSubject: participantConstants.SIGN_IN_STATUS,\n    timeStamp: tournamentStartDate,\n    itemValue,\n  };\n  participant.timeItems.push(timeItem);\n}\n\nfunction addPenalties({ player, participant, tournamentStartDate }) {\n  if (player.penalties) {\n    participant.penalties = [];\n    player.penalties.forEach((penalty) => {\n      const penaltyTime =\n        (isValidDate(penalty.time) && penalty.time) || tournamentStartDate;\n      const penaltyId = utilities.UUID();\n      const penaltyItem = {\n        penaltyId,\n        matchUpId: penalty.muid,\n        penaltyType: getPenaltyType(penalty),\n        notes: penalty.penalty?.label,\n        createdAt: new Date(penaltyTime).toISOString(),\n      };\n      participant.penalties.push(penaltyItem);\n      // TODO: add to matchUp.timeItems\n      /*\n      const timeItem = {\n        itemSubject: \"PENALTY\",\n        itemValue: penaltyItem.penaltyId,\n        timeStamp: penaltyItem.createdAt\n      };\n      */\n    });\n  }\n\n  function getPenaltyType(penalty) {\n    if (penalty.penalty?.value === \"unsporting\")\n      return penaltyConstants.UNSPORTSMANLIKE_CONDUCT;\n    if (penalty.penalty?.value === \"fail2signout\")\n      return penaltyConstants.FAILURE_TO_COMPLETE;\n    if (penalty.penalty?.value === \"illegalcoaching\")\n      return penaltyConstants.COACHING;\n    if (penalty.penalty?.value === \"ballabuse\")\n      return penaltyConstants.BALL_ABUSE;\n    if (penalty.penalty?.value === \"racquetabuse\")\n      return penaltyConstants.RACKET_ABUSE;\n    if (penalty.penalty?.value === \"equipmentabuse\")\n      return penaltyConstants.EQUIMENT_VIOLATION;\n    if (penalty.penalty?.value === \"cursing\")\n      return penaltyConstants.UNSPORTSMANLIKE_CONDUCT;\n    if (penalty.penalty?.value === \"rudegestures\")\n      return penaltyConstants.UNSPORTSMANLIKE_CONDUCT;\n    if (penalty.penalty?.value === \"foullanguage\")\n      return penaltyConstants.UNSPORTSMANLIKE_CONDUCT;\n    if (penalty.penalty?.value === \"timeviolation\")\n      return penaltyConstants.PUNCTUALITY;\n    if (penalty.penalty?.value === \"latearrival\")\n      return penaltyConstants.PUNCTUALITY;\n  }\n}\n","import { getIndoorOutdoor, getSurface } from \"./utilities\";\nimport {\n  participantConstants,\n  participantRoles,\n  utilities,\n} from \"tods-competition-factory\";\nimport { format } from \"date-fns\";\n\n/*\norganisation = club\norganizers\nlocation\n*/\n\nexport function extractTournamentInfo({ tournament, file }) {\n  const tournamentId = tournament.tuid;\n  const organisationId = tournament.org?.ouid;\n\n  const venues = getLocations(tournament);\n  const surfaceCategory = getSurface(tournament);\n  const indoorOutdoor = getIndoorOutdoor(tournament);\n  const onlineResources = getOnlineResources(tournament);\n\n  const tournamentInfo = {\n    tournamentId,\n    tournamentName: tournament.name,\n    startDate:\n      tournament.start &&\n      new Date(format(new Date(tournament.start), \"yyyy-MM-dd\")).toISOString(),\n    endDate:\n      tournament.end &&\n      new Date(format(new Date(tournament.end), \"yyyy-MM-dd\")).toISOString(),\n    parentOrganisationId: organisationId,\n    unifiedTournamentId: {\n      tournamentId,\n      organisationId,\n      organisationName: tournament.org?.name,\n      organisationAbbreviation: tournament.org?.abbr,\n    },\n  };\n  if (venues) tournamentInfo.venues = venues;\n  if (tournament.notes) tournamentInfo.notes = tournament.notes;\n  if (indoorOutdoor) tournamentInfo.indoorOutdoor = indoorOutdoor;\n  if (onlineResources) tournamentInfo.onlineResources = onlineResources;\n  if (surfaceCategory) tournamentInfo.surfaceCategory = surfaceCategory;\n\n  const organisationParticipants = [\n    getRefereeParticipant(tournament.judge),\n    (tournament.umpires || []).map((umpire) => getRefereeParticipant(umpire)),\n  ].filter((f) => f);\n  return { tournamentInfo, organisationParticipants };\n}\n\nfunction getOnlineResources(tournament) {\n  const social = tournament.media?.social || {};\n  const sponsorImages = tournament.publishing?.sponsors || [];\n\n  const onlineResources = Object.keys(social).map((provider) => {\n    const identifier = social[provider];\n    const onlineResource = {\n      provider,\n      identifier,\n      type: \"SOCIAL_MEDIA\",\n    };\n    return onlineResource;\n  });\n\n  sponsorImages.forEach((identifier) => {\n    const onlineResource = {\n      identifier,\n      type: \"SPONSOR\",\n      subType: \"LOGO\",\n    };\n    onlineResources.push(onlineResource);\n  });\n\n  return onlineResources;\n}\n\nfunction getLocations(tournament) {\n  const range = (start, end) =>\n    Array.from({ length: end - start }, (v, k) => k + start);\n  const venues = (tournament.locations || []).map((location) => {\n    const venueId = location.luid;\n    const venueAbbreviation = location.abbreviation;\n    const courts = range(0, parseInt(location.courts)).map((index) => {\n      const identifier =\n        (location.identifiers && location.identifiers[index]) || index + 1;\n      const courtName = `${venueAbbreviation} ${identifier}`;\n      const court = {\n        courtName,\n        courtId: `${venueId}-${index}`,\n      };\n      return court;\n    });\n    const venue = {\n      courts,\n      venueId,\n      venueAbbreviation,\n      venueName: location.name,\n      addresses: [\n        {\n          addressType: \"VENUE\",\n          latitude: location.latitide,\n          longitude: location.longitude,\n          addressLine1: location.address,\n        },\n      ],\n    };\n    return venue;\n  });\n  return venues;\n}\n\nfunction getRefereeParticipant(referee) {\n  if (!referee) return;\n  const [standardGivenName, standardFamilyName] = referee.split(\" \");\n\n  const participantId = utilities.UUID();\n  return {\n    name: referee,\n    participantId,\n    participantType: participantConstants.INDIVIDUAL,\n    participantRole: participantRoles.OFFICIAL,\n    person: {\n      personId: participantId,\n      standardFamilyName,\n      standardGivenName,\n    },\n  };\n}\n","import { extractEvents } from \"./extractEvents\";\nimport { extractParticipants } from \"./extractParticipants\";\nimport { extractTournamentInfo } from \"./extractTournamentInfo\";\n\n// collectionDefinitions, ratings category ranges (event.ratings_filter: { high: #, low: #}), Round Robins\n// player Representatives\n// Compressed draw structures... with D3 visualizations works fine... may not work with React-draws\n// drawEngine.buildDrawHierarchy is not handling pre-round structures which have only one children[] attribute rather than true hierarchy\n\nexport function getTournamentRecordTODS({ tournament }) {\n  const { tournamentInfo, organisationParticipants } = extractTournamentInfo({\n    tournament,\n  });\n  const { competitorParticipants } = extractParticipants({\n    tournament,\n  });\n\n  const participants = competitorParticipants.concat(\n    ...organisationParticipants\n  );\n\n  const { events } = extractEvents({ tournament, participants });\n\n  const tournamentRecord = {\n    ...tournamentInfo,\n    participants,\n    events,\n  };\n\n  return { tournamentRecord };\n}\n\nexport default getTournamentRecordTODS;\n"],"names":["setTypes","S","F","matchFormatCode","fx","stringifySet","setobject","tiebreakSet","tiebreakFormat","setTo","getNumber","NoAD","set_tiebreak","setTiebreak","invalid","tiebreak_at","tiebreakAt","tieobject","tiebreakTo","parseSetFormat","formatstring","parts","split","set_format","indexOf","parseTiebreakFormat","match","isNoAD","validNoAD","parseTiebreakAt","validTiebreakAt","validTiebreak","result","noTiebreak","tiebreak_to","isNaN","Number","stringify","matchformatobject","timed","minutes","timedFormat","bestOf","setFormat","best_of","normal_set","normalSet","final_set","finalSetFormat","filter","f","join","parse","matchformatcode","type","slice","timedMatch","validBestOf","validFinalSet","validSetsFormat","setsMatch","scoreFormat","jsonTODS","score_format","tods","max_sets","parseInt","final_set_supertiebreak","supertiebreak_to","games_for_set","tiebreaks_at","tiereaks_at","dateFx","splitTime","value","o","time","ampm","hours","formatDate","date","separator","format","offsetTime","d","Date","month","getMonth","day","getDate","year","getFullYear","length","localizeDate","date_localization","locale","toLocaleDateString","weekday","timeSort","a","b","as","bs","militaryTime","env","schedule","default_time","toLowerCase","regularTime","convertTime","time24","addWeek","now","setDate","subtractWeek","getDateByWeek","week","dayNum","getDay","requiredDate","HHMMSS","s","sec_num","Math","floor","seconds","pad_hours","display_seconds","weekDays","map","i","index","diff","dayOfWeek","ymd2date","ymd","offsetDate","targetTime","tzDifference","getTimezoneOffset","getTime","validDate","datestring","range","dateparts","start","end","isDate","dateArg","t","valueOf","timeUTC","dateDate","UTC","dateFromDay","randomDate","random","dateRange","startDt","endDt","maxDate","between","iterations","keep_looping","currentDate","console","log","push","sameDay","d1","d2","futureDate","days","extractMatchUp","eventType","seedLimit","tieFormat","entryStage","legacyMatch","participants","matchUpFormat","participantIds","drawPositionOffset","tournamentEngine","matchUpId","muid","sides","entries","seedAssignments","missingParticipants","positionAssignments","isBye","Array","isArray","teams","forEach","team","participantId","individualParticipantIds","player","id","player1","player2","drawPosition","draw_position","seed","bye","participant","getPairedParticipant","addParticipant","participantType","participantRole","_participant","side","sideNumber","includes","entryStatus","entryStatusConstants","DIRECT_ACCEPTANCE","seedNumber","seedValue","matchUpType","_legacyMatch$format","toUpperCase","collectionDefinition","collectionDefinitions","find","collectionId","scoreString","score","reversedScoreString","irreversible","reversed","set","divider","set_scores","parseSetScore","reverse","set_games","games","tb_scores","tiebreak","ss","sst","test","exec","reverseScore","winner_index","undefined","winner","winningSide","scoreStringSide1","matchTiebreakTODS","scoreStringSide2","sets","mocksEngine","parseScoreString","live","interrupted","incomplete","walkover","cancelled","abandoned","defaulted","retired","matchUpStatus","matchUpStatusConstants","IN_PROGRESS","SUSPENDED","INCOMPLETE","WALKOVER","NOT_PLAYED","ABANDONED","DEFAULTED","RETIRED","BYE","COMPLETED","TO_BE_PLAYED","timeItems","umpire","luid","timeItem","itemType","itemValue","timeStamp","toISOString","startTime","properTime","startDateTime","endTime","endDateTime","official","participantConstants","INDIVIDUAL","participantRoles","OFFICIAL","name","getTimeItems","matchUp","drawPositions","formatCode","matchFormat","collectionPosition","sequence","part","number","toString","matchTiebreak","surfaceCategoryMap","C","H","G","R","getSurface","element","surface","getIndoorOutdoor","inout","intersection","n","e","c","getGender","genderConstants","FEMALE","MALE","MIXED","getStage","legacyEvent","stageMap","E","drawDefinitionConstants","MAIN","Q","QUALIFYING","CONSOLATION","P","PLAY_OFF","A","draw_type","Object","keys","links","typeCheck","tc","active","direction","draw","compass","structure","isConsolation","isFeedIn","isBackdraw","tournament","dual_matches","event_type","qualifying_bracket_seeding","drawFx","isQualifying","approved","qualifiers","draw_size","ctuuid","from","v","k","scoreFx","validInt","convertStringScore","string_score","outcome","match_format","scores","m","tbscore","min_games","min","sf","spacer","st","supertiebreak","outome","setsToWin","ceil","isFinalSet","getExistingScores","generateMatchFormat","cfg_obj","bestof","ddlb","getValue","sets_to_win","setsto","tiebreaksat","tiebreaksto","supertiebreakto","finalset","getScoringFormat","objects","target","scoring_format","source","assign","defaultMatchFormat","category","matchFormats","scoreboard","formats","D","categories","singles","UUID","self","lut","getWindow","window","getRandomValuesFunc","crypto","getRandomValues","dvals","Uint32Array","d0","d3","formatUuid","idGen","generate","playersHash","players","p","sort","opts","unique","arr","item","lastIndexOf","indices","val","reduce","occurrences","r","randomPop","array","splice","subSort","sortFx","concat","standard_draws","draw_sizes","validDrawSize","rr_h2h_priority","compressed_draw_formats","compressed","byes_adjacent_to_seeds","seedBlocks","seed_limits","bye_placement","seedPositions","separation","acceptedDrawSizes","num_players","standardSizes","forceCompressed","standardDrawSize","bracketMatches","bracket_index","brackets","bracket","teamsHash","match_ups","teamMatchups","matchup","defunct","matches","emu","pairing","pruneDefunctMatches","team_matchups","matches_hash","tm","round_name","ids","bracketRounds","numArr","count","_","positions","round","rounds","a_row","b_row","j","a_head","shift","a_down","pop","b_up","calcBracketRounds","collapseHierarchy","node","depth","_height","height","_children","children","treeInfo","collapse","calc_tree","draw_hierarchy","maxTreeDepth","nodes","descendants","max","byes","data","structural_byes","match_nodes","matchNode","bye_nodes","teamMatch","double_bye_nodes","byeNode","all_matches","max_round","upcoming_match_nodes","byeChild","qualifier","qualifierChild","doubles","draw_positions","dp","seeds","final_round","final_round_players","unassigned","assignments","assigned_positions","total_matches","complete","bracketComplete","drawRounds","bin","calcFeedSize","first_round_size","skip_rounds","feed_rounds","feed_capacity","skip_reduce","draw_rounds","feed_diff","pow","drawInfo","bracket_size","position","bracketDrawPositions","opponents","total","seed_placements","placements","unfinished_seed_placements","unseeded_placements","u","bye_placements","hashFx","h","p_hash","unfilled_positions","completed_brackets","positions_filled","unseeded_teams","unplaced_seeds","open_seed_positions","placed_seeds","seeded_teams","rrInfo","info","blankDraw","offset","x","structuralByes","bit_flip","cluster_size","sByes","clusters","cluster","bye_positions","odd","p2","buildRound","tree","fed","pos","child1","child2","nuid","feedRound","remaining","feed_arm","feed","buildDraw","assignPosition","propagate","assigned","entry","child","findPositionNode","advancePosition","onlyIfBye","position_node","advanceToNode","matchDrawPositions","advanced","current_match","match_draw_positions","next_round_match","next_round_score","next_round_draw_positions","error","cdpi","containsByeTeam","teamIsBye","opponent_is_bye","loser","advance","total_players","evt","limit","event_seed_limit","threshold","playerPositions","seed_positions","placeSeedGroup","group_index","current_draw","seed_group","nextSeedGroup","missing_seeds","pushBracketTeam","unplaced","unplacedSeedGroups","sp","findCandidate","sortNumber","structural_bye_positions","unassigned_positions","opponent","largestGroup","unplaced_opponents","groupings","grouping","teamGrouping","max_length","min_length","groupings_meets_max","groupings_meets_min","random_group","findOpponent","unpairedPositions","opponent_teams","grouping_positions","opponent_id","opponent_groupings","opponent_grouping_positions","gp","all_positions","group_not_present","size","chunksize","all","one","ch","row","checkChunk","group_present","no_group_unpaired","unpaired","no_group_unassigned","viable_sections","section","true_positions","truePosition","true_position","pairAssigned","chunk","g","matchTeams","feedNode","includeQualifiers","findMatchNodeByTeamPositions","match_node","match_positions","treeMatches","round_offset","round_names","calculated_round_names","potentials","calculated_round_name","l","dependencies","this_match","dependent","parent","keyWalk","options","treeDrawMatchOrder","roundRobinRounds","event","rrbr","qualifying","max_rounds","br","matchups","bracketMatchups","matchhashes","compassInfo","expandHierarchy","replaceDrawPlayer","existing_player","new_player_data","opponent_team","checkReplacePlayer","key","placement","dm","dual_match","calcFeedBase","feedDrawSize","burn","addByes","max_draw_position","walkNode","descent","addBye","dispersion","values","feedInDraw","team_count","buildQualDraw","num_qualifiers","section_size","modifyPositionScore","target_node","schedulePosition","venue","seedBlock","seed_block","roundrobinSeedPlacements","bracket_count","seeded_team_keys","auto_placed_seeds","random_placed_seeds","seed_index","qualifyingBracketSeeding","validSeedPlacements","random_sort","seed_limit","qualifying_draw","distributeByes","target_byes","paired_positions","pairs_no_seed","pairs_with_seed","prescribed","adjacent_pairs","sb","structural_seed_order","adjacent_to_seeds","assignment","pairs_no_seed_or_bye","pair","flat_pairs","getBye","filtered_pairs","rand","rrByeDistribution","rrUnseededPlacements","exit","unplaced_teams","unplacedTeams","team_diff","placeTeam","randomRRunseededSeparation","randomRRunseededDistribution","distributeQualifiers","sections","dprange","available_positions","seededTeams","placeSeedGroups","roundMatches","placeUnseededTeams","randomUnseededSeparation","randomUnseededDistribution","matchNodes","feedNodes","byeTeams","drawPositionsWithBye","replaceEmptiesWithByes","advanceTeamsWithByes","unadvanced","unadvanced_dp","bye_dp","unadvanced_double_byes","findDualMatchNodeByMatch","dual_match_muid","findDualMatchMuid","findDualMatchNode","y","findRRDualMatch","upcomingMatches","compass_data","pre","names","upcomingCompassMatches","east","west","north","south","northeast","northwest","southeast","southwest","compassMatches","result_order","tallyBracket","per_player","bracket_match_format","disqualified","team_results","match_result_order","h2h","wH","getIdentifier","lH","team1","team2","checkTeam","matches_cancelled","disqualifyingScore","matches_won","matches_lost","defeats","victories","sets_tally","countSets","sets_won","sets_lost","games_tally","min_winning_games","set_score","total_sets","tallied_games","complement","getComplement","countGames","games_won","games_lost","points_tally","countPoints","points_won","points_lost","bracket_sets_to_win","bracket_games_for_set","phash","sets_numerator","sets_total","sets_ratio","Infinity","matches_numerator","matches_ratio","games_numerator","games_denominator","games_total","games_ratio","games_difference","points_ratio","order","team_ids","total_opponents","team_id","results","order_hash","ratioHash","orderHash","ratio_hash","wins","h2hOrder","orderHashSort","hash_order","rank_order","rank_hash","h2hRatio","ratioHashSort","ratio_order","points_order","h2h_a","h2h_b","determineTeamOrder","ro_list","qorder","sub_order","id_order","walkedOver","valuesObject","optionsObject","vKeys","oKeys","oo","constructor","extractDrawPlayers","tallyBracketAndModifyPlayers","reset","tbr","ic","valid_for_suborder","results_order","matchFx","dfx","tournamentEventMatches","events","completed_matches","pending_matches","upcoming_matches","drawTypeSort","oe","isRoundRobin","upcoming","event_matches","eventMatches","replace","matchStorageObject","isTeam","roundNames","checkScheduledMatches","calculated_names","upcomingEventMatches","eventMatchStorageObjects","localeCompare","team_players","coords","match_teams","safeArr","team0","locations","loc","latitude","longitude","obj","consolation","location","isDoubles","gender","delegated_score","status","tuid","org","rank","euid","custom_category","fullName","last_name","first_name","isAdHoc","findEventByID","hasRoundNames","qlink","isPlayoff","addMUIDs","court_names","max_matches_per_court","courts","identifiers","court","abbreviation","availability","courtData","ct","check_names","oop_round","court_matches","after","addMUID","datePDF","timestamp","zeroPad","displayDate","activeTeamPlayers","matchPlayers","pc","flatten","winners","losers","match_players","opponentsInclude","removeMatchSchedule","opponent_ids","matchOutcome","winning_team","losing_team","player_won","winning_ids","losing_ids","pindex","scheduledMatches","scheduled","dualMatchMatches","containsGUIDplayer","eventRoundConsolationReady","round_matches","with_team","getLuckyLosers","evnt","all_rounds","ll_all_rounds","qualifying_ids","qualified","q","losing_players","determineGender","genders","sex","matchTime","matchRound","matchDate","matchDesignator","matchDateDisplay","matchDuration","getSeconds","duration","hm","mod","getNum","roundPosition","backdrawTarget","match_round","backdraw_target","muids","roundNumber","DrawStructure","matchFinish","matchCourt","matchScore","non_breaking","scr","isByeMatch","idInMatch","flat","toFlatten","CONTAINER","ITEM","ROUND_OUTCOME","WIN_RATIO","processLegacyMatch","tieMatches","roundNumberString","_legacyMatch$match2","roundPositionString","roundName","_legacyMatch$match4","tieMatchUps","tieMatch","matchUpPositionAssignments","matchUpSeedAssignments","matchUpEntries","tieMatchUp","lineUp","competitor","collectionAssignments","positionAssignment","seedAssignment","extractEvents","eventCategories","legacyEvents","setState","tournamentId","linkedStructures","eventIds","groupEuid","structureGroup","groupStructures","structureGroupDrawTypes","mainDrawTypes","mainLegacyEvent","eventConstants","SINGLES","DOUBLES","getMatchUpType","matchorder","matchUpTypes","TEAM","ageCategoryCode","U10","U12","U14","U16","U18","Senior","getAgeCategoryCode","categoryName","totalTieValue","automated","draw_created","broadcast_name","legacyCategory","utilities","collectionMatchUps","collectionValue","parseFloat","collectionValueProfile","matchUpValue","matchUpsCount","collectionName","winCriteria","valueGoal","mainStructureId","entriesAccumulator","structures","props","legacyDual","feed_base","matchUps","matchUpAssignments","structureName","structureType","structureId","stageSequence","finishingPosition","roundRobinStructure","dfxMatches","eliminationStructure","getStructureContent","stage","drawEntries","extractStructures","drawDefinition","drawId","drawName","factoryConstants","createdAt","drawProfile","drawSize","addDrawDefinitionExtension","extension","eventId","surfaceCategory","indoorOutdoor","eventRank","drawDefinitions","eventName","isValidDate","trim","errorConditionConstants","INVALID_DATE","err","getName","text","normalizeName","getRefereeParticipant","referee","standardGivenName","standardFamilyName","person","personId","getTournamentRecordTODS","organisationId","_tournament$org","ouid","venues","venueId","venueAbbreviation","courtName","courtId","venueName","addresses","addressType","latitide","addressLine1","address","getLocations","onlineResources","social","media","sponsorImages","publishing","sponsors","provider","identifier","subType","getOnlineResources","tournamentInfo","tournamentName","startDate","endDate","parentOrganisationId","unifiedTournamentId","organisationName","_tournament$org2","organisationAbbreviation","_tournament$org3","abbr","notes","organisationParticipants","judge","umpires","extractTournamentInfo","competitorParticipants","file","individualParticipants","tournamentStartDate","tournamentCategory","puid","participantName","birthDate","birth","COMPETITOR","nationalityCode","ioc","otherNames","itemSubject","SIGN_IN_STATUS","signed_in","SIGNED_IN","SIGNED_OUT","nickname","addOtherNames","cropin","personOtherIds","uniqueOrganisationName","addOtherIds","rankings","scaleConstants","SCALE","RANKING","category_dbls","addRankings","ratings","ratingType","RATING","addRatings","getPenaltyType","penalty","penaltyConstants","UNSPORTSMANLIKE_CONDUCT","FAILURE_TO_COMPLETE","COACHING","BALL_ABUSE","RACKET_ABUSE","EQUIMENT_VIOLATION","PUNCTUALITY","penalties","penaltyTime","penaltyItem","penaltyId","penaltyType","_penalty$penalty","label","addPenalties","extractIndividualParticipants","pairParticipants","matchingParticipantId","foundInOtherIds","_participant$person","_participant$person$p","otherId","pairParticipant","PAIR","extractPairParticipants","teamParticipants","extractParticipants","tournamentRecord"],"mappings":"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,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,MAGJC,cAAe,GACV,CAAC,CAAC,IAAK,QACP,CAAC,CAAC,IAAK,QACP,CACD,CAAC,IAAK,QACN,CAAC,IAAK,WAEL,CACD,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,WAEL,CACD,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,QACN,CAAC,IAAK,YAEJ,MACA,CACF,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,SACN,CAAC,IAAK,aAEJ,MACA,CACF,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAA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"}